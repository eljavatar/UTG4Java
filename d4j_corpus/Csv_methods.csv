id,project,version,number_method_by_version,modified_class,focal_class,path_focal_class_in_project,test_class,path_test_class_scaffolding,package_focal_class,imports_focal_class,src_fm_fc_ms_ff,src_fm_fc_dctx,src_fm_fc_dctx_priv
Csv_1_0_ExtendedBufferedReader,Csv,1,0,org.apache.commons.csv.ExtendedBufferedReader,ExtendedBufferedReader,src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java,ExtendedBufferedReader_ESTest,org/apache/commons/csv/ExtendedBufferedReader_ESTest.java,"package org.apache.commons.csv;","import java.io.BufferedReader;|import java.io.IOException;|import java.io.Reader;","ExtendedBufferedReader extends BufferedReader { @Override public int read() throws IOException { int current = super.read(); if (current == '\r' || (current == '\n' && lastChar != '\r')) { lineCounter++; } lastChar = current; return lastChar; } ExtendedBufferedReader(Reader); @Override public int read(); int readAgain(); @Override public int read(char[], int, int); @Override public String readLine(); int lookAhead(); int getLineNumber(); static final int END_OF_STREAM = -1; static final int UNDEFINED = -2; }","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public int read() throws IOException { int current = super.read(); if (current == '\r' || (current == '\n' && lastChar != '\r')) { lineCounter++; } lastChar = current; return lastChar; } ExtendedBufferedReader(Reader); private int lastChar = UNDEFINED; private int lineCounter = 0; }</FCTX> <ECTX></ECTX>","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public int read() throws IOException { int current = super.read(); if (current == '\r' || (current == '\n' && lastChar != '\r')) { lineCounter++; } lastChar = current; return lastChar; } ExtendedBufferedReader(Reader); <PRIVATE_FCTX>private int lastChar = UNDEFINED; private int lineCounter = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_1_1_ExtendedBufferedReader,Csv,1,1,org.apache.commons.csv.ExtendedBufferedReader,ExtendedBufferedReader,src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java,ExtendedBufferedReader_ESTest,org/apache/commons/csv/ExtendedBufferedReader_ESTest.java,"package org.apache.commons.csv;","import java.io.BufferedReader;|import java.io.IOException;|import java.io.Reader;","ExtendedBufferedReader extends BufferedReader { @Override public int read(char[] buf, int offset, int length) throws IOException { if (length == 0) { return 0; } int len = super.read(buf, offset, length); if (len > 0) { for (int i = offset; i < offset + len; i++) { char ch = buf[i]; if (ch == '\n') { if ('\r' != (i > 0 ? buf[i-1]: lastChar)) { lineCounter++; } } else if (ch == '\r') { lineCounter++; } } lastChar = buf[offset + len - 1]; } else if (len == -1) { lastChar = END_OF_STREAM; } return len; } ExtendedBufferedReader(Reader); @Override public int read(); int readAgain(); @Override public int read(char[], int, int); @Override public String readLine(); int lookAhead(); int getLineNumber(); static final int END_OF_STREAM = -1; static final int UNDEFINED = -2; }","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public int read(char[] buf, int offset, int length) throws IOException { if (length == 0) { return 0; } int len = super.read(buf, offset, length); if (len > 0) { for (int i = offset; i < offset + len; i++) { char ch = buf[i]; if (ch == '\n') { if ('\r' != (i > 0 ? buf[i-1]: lastChar)) { lineCounter++; } } else if (ch == '\r') { lineCounter++; } } lastChar = buf[offset + len - 1]; } else if (len == -1) { lastChar = END_OF_STREAM; } return len; } ExtendedBufferedReader(Reader); private int lastChar = UNDEFINED; private int lineCounter = 0; }</FCTX> <ECTX></ECTX>","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public int read(char[] buf, int offset, int length) throws IOException { if (length == 0) { return 0; } int len = super.read(buf, offset, length); if (len > 0) { for (int i = offset; i < offset + len; i++) { char ch = buf[i]; if (ch == '\n') { if ('\r' != (i > 0 ? buf[i-1]: lastChar)) { lineCounter++; } } else if (ch == '\r') { lineCounter++; } } lastChar = buf[offset + len - 1]; } else if (len == -1) { lastChar = END_OF_STREAM; } return len; } ExtendedBufferedReader(Reader); <PRIVATE_FCTX>private int lastChar = UNDEFINED; private int lineCounter = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_1_2_ExtendedBufferedReader,Csv,1,2,org.apache.commons.csv.ExtendedBufferedReader,ExtendedBufferedReader,src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java,ExtendedBufferedReader_ESTest,org/apache/commons/csv/ExtendedBufferedReader_ESTest.java,"package org.apache.commons.csv;","import java.io.BufferedReader;|import java.io.IOException;|import java.io.Reader;","ExtendedBufferedReader extends BufferedReader { @Override public String readLine() throws IOException { String line = super.readLine(); if (line != null) { if (line.length() > 0) { lastChar = line.charAt(line.length() - 1); } lineCounter++; } else { lastChar = END_OF_STREAM; } return line; } ExtendedBufferedReader(Reader); @Override public int read(); int readAgain(); @Override public int read(char[], int, int); @Override public String readLine(); int lookAhead(); int getLineNumber(); static final int END_OF_STREAM = -1; static final int UNDEFINED = -2; }","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public String readLine() throws IOException { String line = super.readLine(); if (line != null) { if (line.length() > 0) { lastChar = line.charAt(line.length() - 1); } lineCounter++; } else { lastChar = END_OF_STREAM; } return line; } ExtendedBufferedReader(Reader); private int lastChar = UNDEFINED; private int lineCounter = 0; }</FCTX> <ECTX></ECTX>","<FCTX>ExtendedBufferedReader extends BufferedReader { @Override public String readLine() throws IOException { String line = super.readLine(); if (line != null) { if (line.length() > 0) { lastChar = line.charAt(line.length() - 1); } lineCounter++; } else { lastChar = END_OF_STREAM; } return line; } ExtendedBufferedReader(Reader); <PRIVATE_FCTX>private int lastChar = UNDEFINED; private int lineCounter = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_0_CSVRecord,Csv,2,0,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_1_CSVRecord,Csv,2,1,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index.intValue(), values.length)); } } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index.intValue(), values.length)); } } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index.intValue(), values.length)); } } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values; private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_2_CSVRecord,Csv,2,2,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values; private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_3_CSVRecord,Csv,2,3,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_4_CSVRecord,Csv,2,4,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values; private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_5_CSVRecord,Csv,2,5,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return Arrays.asList(values).iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return Arrays.asList(values).iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return Arrays.asList(values).iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_6_CSVRecord,Csv,2,6,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_7_CSVRecord,Csv,2,7,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_8_CSVRecord,Csv,2,8,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_2_9_CSVRecord,Csv,2,9,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.Iterator;|import java.util.Map;","CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(int); public String get(String); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); String[] values(); public String getComment(); public long getRecordNumber(); public int size(); @Override public String toString(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_4_0_CSVParser,Csv,4,0,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_4_1_CSVParser,Csv,4,1,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_4_2_CSVParser,Csv,4,2,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName(""UTF-8"") : charset), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName(""UTF-8"") : charset), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName(""UTF-8"") : charset), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_4_3_CSVParser,Csv,4,3,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); void close(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); void close(); }</ECTX>"
Csv_4_4_CSVParser,Csv,4,4,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>"
Csv_4_5_CSVParser,Csv,4,5,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); private final Map<String, Integer> headerMap; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Map<String, Integer> headerMap;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_4_6_CSVParser,Csv,4,6,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); private long recordNumber; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private long recordNumber;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_4_7_CSVParser,Csv,4,7,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { final List<CSVRecord> records = new ArrayList<CSVRecord>(); CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { final List<CSVRecord> records = new ArrayList<CSVRecord>(); CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { final List<CSVRecord> records = new ArrayList<CSVRecord>(); CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_4_8_CSVParser,Csv,4,8,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>"
Csv_4_9_CSVParser,Csv,4,9,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_0_CSVPrinter,Csv,5,0,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_1_CSVPrinter,Csv,5,1,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_2_CSVPrinter,Csv,5,2,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_3_CSVPrinter,Csv,5,3,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); private void print(Object, CharSequence, int, int); private final CSVFormat format; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public String getNullString(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private void print(Object, CharSequence, int, int); private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public String getNullString(); }</ECTX>"
Csv_5_4_CSVPrinter,Csv,5,4,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public boolean isCommentingEnabled(); public Character getCommentStart(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public boolean isCommentingEnabled(); public Character getCommentStart(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>"
Csv_5_5_CSVPrinter,Csv,5,5,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public String getRecordSeparator(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public String getRecordSeparator(); }</ECTX>"
Csv_5_6_CSVPrinter,Csv,5,6,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_7_CSVPrinter,Csv,5,7,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_8_CSVPrinter,Csv,5,8,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_9_CSVPrinter,Csv,5,9,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_5_10_CSVPrinter,Csv,5,10,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_0_CSVRecord,Csv,6,0,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_1_CSVRecord,Csv,6,1,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_2_CSVRecord,Csv,6,2,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_3_CSVRecord,Csv,6,3,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_4_CSVRecord,Csv,6,4,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_5_CSVRecord,Csv,6,5,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_6_CSVRecord,Csv,6,6,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_7_CSVRecord,Csv,6,7,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_8_CSVRecord,Csv,6,8,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_9_CSVRecord,Csv,6,9,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_10_CSVRecord,Csv,6,10,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); private List<String> toList(); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private List<String> toList();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_6_11_CSVRecord,Csv,6,11,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_0_CSVParser,Csv,7,0,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new FileReader(file), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_7_1_CSVParser,Csv,7,1,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_7_2_CSVParser,Csv,7,2,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_3_CSVParser,Csv,7,3,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_7_4_CSVParser,Csv,7,4,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); void close(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); void close(); }</ECTX>"
Csv_7_5_CSVParser,Csv,7,5,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>"
Csv_7_6_CSVParser,Csv,7,6,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); private final Map<String, Integer> headerMap; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Map<String, Integer> headerMap;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_7_CSVParser,Csv,7,7,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); private long recordNumber; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private long recordNumber;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_8_CSVParser,Csv,7,8,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_9_CSVParser,Csv,7,9,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_7_10_CSVParser,Csv,7,10,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;","CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>"
Csv_8_0_CSVFormat,Csv,8,0,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_1_CSVFormat,Csv,8,1,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quotePolicy != other.quotePolicy) { return false; } if (quoteChar == null) { if (other.quoteChar != null) { return false; } } else if (!quoteChar.equals(other.quoteChar)) { return false; } if (commentStart == null) { if (other.commentStart != null) { return false; } } else if (!commentStart.equals(other.commentStart)) { return false; } if (escape == null) { if (other.escape != null) { return false; } } else if (!escape.equals(other.escape)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quotePolicy != other.quotePolicy) { return false; } if (quoteChar == null) { if (other.quoteChar != null) { return false; } } else if (!quoteChar.equals(other.quoteChar)) { return false; } if (commentStart == null) { if (other.commentStart != null) { return false; } } else if (!commentStart.equals(other.commentStart)) { return false; } if (escape == null) { if (other.escape != null) { return false; } } else if (!escape.equals(other.escape)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quotePolicy != other.quotePolicy) { return false; } if (quoteChar == null) { if (other.quoteChar != null) { return false; } } else if (!quoteChar.equals(other.quoteChar)) { return false; } if (commentStart == null) { if (other.commentStart != null) { return false; } } else if (!commentStart.equals(other.commentStart)) { return false; } if (escape == null) { if (other.escape != null) { return false; } } else if (!escape.equals(other.escape)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_2_CSVFormat,Csv,8,2,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getQuoteChar() { return quoteChar; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getQuoteChar() { return quoteChar; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getQuoteChar() { return quoteChar; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_3_CSVFormat,Csv,8,3,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Quote getQuotePolicy() { return quotePolicy; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Quote getQuotePolicy() { return quotePolicy; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Quote getQuotePolicy() { return quotePolicy; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_4_CSVFormat,Csv,8,4,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_5_CSVFormat,Csv,8,5,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_6_CSVFormat,Csv,8,6,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode()); result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode()); result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode()); result = prime * result + ((escape == null) ? 0 : escape.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode()); result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode()); result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode()); result = prime * result + ((escape == null) ? 0 : escape.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode()); result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode()); result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode()); result = prime * result + ((escape == null) ? 0 : escape.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_7_CSVFormat,Csv,8,7,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isCommentingEnabled() { return commentStart != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isCommentingEnabled() { return commentStart != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character commentStart; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isCommentingEnabled() { return commentStart != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character commentStart;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_8_CSVFormat,Csv,8,8,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isEscaping() { return escape != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isEscaping() { return escape != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character escape; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isEscaping() { return escape != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character escape;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_9_CSVFormat,Csv,8,9,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isNullHandling() { return nullString != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isNullHandling() { return nullString != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String nullString; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isNullHandling() { return nullString != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String nullString;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_10_CSVFormat,Csv,8,10,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isQuoting() { return quoteChar != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isQuoting() { return quoteChar != null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character quoteChar; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isQuoting() { return quoteChar != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character quoteChar;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_11_CSVFormat,Csv,8,11,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_12_CSVFormat,Csv,8,12,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>"
Csv_8_13_CSVFormat,Csv,8,13,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscaping()) { sb.append(' '); sb.append(""Escape=<"").append(escape).append('>'); } if (isQuoting()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteChar).append('>'); } if (isCommentingEnabled()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentStart).append('>'); } if (isNullHandling()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscaping()) { sb.append(' '); sb.append(""Escape=<"").append(escape).append('>'); } if (isQuoting()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteChar).append('>'); } if (isCommentingEnabled()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentStart).append('>'); } if (isNullHandling()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Character commentStart; private final Character escape; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscaping()) { sb.append(' '); sb.append(""Escape=<"").append(escape).append('>'); } if (isQuoting()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteChar).append('>'); } if (isCommentingEnabled()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentStart).append('>'); } if (isNullHandling()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Character commentStart; private final Character escape; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_14_CSVFormat,Csv,8,14,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentStart(final char commentStart) { return withCommentStart(Character.valueOf(commentStart)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentStart(final char commentStart) { return withCommentStart(Character.valueOf(commentStart)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character commentStart; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentStart(final char commentStart) { return withCommentStart(Character.valueOf(commentStart)); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character commentStart;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_15_CSVFormat,Csv,8,15,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentStart(final Character commentStart) { if (isLineBreak(commentStart)) { throw new IllegalArgumentException(""The comment start character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentStart(final Character commentStart) { if (isLineBreak(commentStart)) { throw new IllegalArgumentException(""The comment start character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentStart(final Character commentStart) { if (isLineBreak(commentStart)) { throw new IllegalArgumentException(""The comment start character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_16_CSVFormat,Csv,8,16,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_17_CSVFormat,Csv,8,17,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character escape; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character escape;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_18_CSVFormat,Csv,8,18,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_19_CSVFormat,Csv,8,19,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_20_CSVFormat,Csv,8,20,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_21_CSVFormat,Csv,8,21,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_22_CSVFormat,Csv,8,22,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_23_CSVFormat,Csv,8,23,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getCommentStart() { return commentStart; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getCommentStart() { return commentStart; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getCommentStart() { return commentStart; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_24_CSVFormat,Csv,8,24,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteChar(final char quoteChar) { return withQuoteChar(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteChar(final char quoteChar) { return withQuoteChar(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character quoteChar; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteChar(final char quoteChar) { return withQuoteChar(Character.valueOf(quoteChar)); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final Character quoteChar;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_25_CSVFormat,Csv,8,25,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteChar(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteChar(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteChar(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_26_CSVFormat,Csv,8,26,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuotePolicy(final Quote quotePolicy) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuotePolicy(final Quote quotePolicy) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuotePolicy(final Quote quotePolicy) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_27_CSVFormat,Csv,8,27,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_28_CSVFormat,Csv,8,28,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_29_CSVFormat,Csv,8,29,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final char delimiter; private final Character quoteChar; private final Quote quotePolicy; private final Character commentStart; private final Character escape; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_30_CSVFormat,Csv,8,30,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_31_CSVFormat,Csv,8,31,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getEscape() { return escape; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getEscape() { return escape; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getEscape() { return escape; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_32_CSVFormat,Csv,8,32,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_33_CSVFormat,Csv,8,33,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_34_CSVFormat,Csv,8,34,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_8_35_CSVFormat,Csv,8,35,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentStart(); public char getDelimiter(); public Character getEscape(); public String[] getHeader(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteChar(); public Quote getQuotePolicy(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentingEnabled(); public boolean isEscaping(); public boolean isNullHandling(); public boolean isQuoting(); public CSVParser parse(Reader); @Override public String toString(); void validate(); public CSVFormat withCommentStart(char); public CSVFormat withCommentStart(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuoteChar(char); public CSVFormat withQuoteChar(Character); public CSVFormat withQuotePolicy(Quote); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuoteChar(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } <PRIVATE_FCTX>private CSVFormat(char, Character, Quote, Character, Character, boolean, boolean, String, String, String[], boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_0_CSVRecord,Csv,9,0,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_1_CSVRecord,Csv,9,1,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_2_CSVRecord,Csv,9,2,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_3_CSVRecord,Csv,9,3,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_4_CSVRecord,Csv,9,4,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( ""No header mapping was specified, the record values can't be accessed by name""); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format(""Mapping for %s not found, expected one of %s"", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( ""Index for header '%s' is %d but CSVRecord only has %d values!"", name, index, Integer.valueOf(values.length))); } } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_5_CSVRecord,Csv,9,5,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_6_CSVRecord,Csv,9,6,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_7_CSVRecord,Csv,9,7,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null || mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null || mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null || mapping.size() == values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_8_CSVRecord,Csv,9,8,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null && mapping.containsKey(name); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null && mapping.containsKey(name); } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null && mapping.containsKey(name); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_9_CSVRecord,Csv,9,9,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final Map<String, Integer> mapping; private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final Map<String, Integer> mapping; private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_10_CSVRecord,Csv,9,10,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); private List<String> toList(); }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private List<String> toList();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_9_11_CSVRecord,Csv,9,11,org.apache.commons.csv.CSVRecord,CSVRecord,src/main/java/org/apache/commons/csv/CSVRecord.java,CSVRecord_ESTest,org/apache/commons/csv/CSVRecord_ESTest.java,"package org.apache.commons.csv;","import java.io.Serializable;|import java.util.Arrays;|import java.util.HashMap;|import java.util.Iterator;|import java.util.List;|import java.util.Map;|import java.util.Map.Entry;","CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); public String get(Enum<?>); public String get(int); public String get(String); public String getComment(); public long getRecordNumber(); public boolean isConsistent(); public boolean isMapped(String); public boolean isSet(String); public Iterator<String> iterator(); <M extends Map<String, String>> M putIn(M); public int size(); public Map<String, String> toMap(); @Override public String toString(); String[] values(); }","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); private final String[] values; }</FCTX> <ECTX></ECTX>","<FCTX>CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(String[], Map<String,Integer>, String, long); <PRIVATE_FCTX>private final String[] values;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_0_CSVPrinter,Csv,10,0,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_1_CSVPrinter,Csv,10,1,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_2_CSVPrinter,Csv,10,2,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_3_CSVPrinter,Csv,10,3,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); private void print(Object, CharSequence, int, int); private final CSVFormat format; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getNullString(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private void print(Object, CharSequence, int, int); private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getNullString(); }</ECTX>"
Csv_10_4_CSVPrinter,Csv,10,4,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public boolean isCommentingEnabled(); public Character getCommentStart(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public boolean isCommentingEnabled(); public Character getCommentStart(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>"
Csv_10_5_CSVPrinter,Csv,10,5,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getRecordSeparator(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getRecordSeparator(); }</ECTX>"
Csv_10_6_CSVPrinter,Csv,10,6,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_7_CSVPrinter,Csv,10,7,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_8_CSVPrinter,Csv,10,8,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_9_CSVPrinter,Csv,10,9,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_10_10_CSVPrinter,Csv,10,10,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); public void close(); public void flush(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object[]); public void printRecords(ResultSet); public Appendable getOut(); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_0_CSVParser,Csv,11,0,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_11_1_CSVParser,Csv,11,1,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_11_2_CSVParser,Csv,11,2,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException(""CSVParser has been closed""); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException(""No more CSV records available""); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_3_CSVParser,Csv,11,3,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_11_4_CSVParser,Csv,11,4,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); public void close(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); public void close(); }</ECTX>"
Csv_11_5_CSVParser,Csv,11,5,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>"
Csv_11_6_CSVParser,Csv,11,6,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); private final Map<String, Integer> headerMap; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Map<String, Integer> headerMap;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_7_CSVParser,Csv,11,7,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); private long recordNumber; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private long recordNumber;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_8_CSVParser,Csv,11,8,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_9_CSVParser,Csv,11,9,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_11_10_CSVParser,Csv,11,10,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.FileReader;|import java.io.IOException;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Collection;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import static org.apache.commons.csv.Token.Type.*;","CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); public static CSVParser parse(File, Charset, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); public void close(); public long getCurrentLineNumber(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public <T extends Collection<CSVRecord>> T getRecords(T); public boolean isClosed(); public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>"
Csv_12_0_CSVFormat,Csv,12,0,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_1_CSVFormat,Csv,12,1,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_2_CSVFormat,Csv,12,2,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_3_CSVFormat,Csv,12,3,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_4_CSVFormat,Csv,12,4,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_5_CSVFormat,Csv,12,5,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_6_CSVFormat,Csv,12,6,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_7_CSVFormat,Csv,12,7,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_8_CSVFormat,Csv,12,8,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_9_CSVFormat,Csv,12,9,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character escapeCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character escapeCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_10_CSVFormat,Csv,12,10,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String nullString; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String nullString;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_11_CSVFormat,Csv,12,11,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character quoteCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character quoteCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_12_CSVFormat,Csv,12,12,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>"
Csv_12_13_CSVFormat,Csv,12,13,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_14_CSVFormat,Csv,12,14,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_15_CSVFormat,Csv,12,15,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_16_CSVFormat,Csv,12,16,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_17_CSVFormat,Csv,12,17,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_18_CSVFormat,Csv,12,18,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_19_CSVFormat,Csv,12,19,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_20_CSVFormat,Csv,12,20,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_21_CSVFormat,Csv,12,21,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_22_CSVFormat,Csv,12,22,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_23_CSVFormat,Csv,12,23,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_24_CSVFormat,Csv,12,24,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_25_CSVFormat,Csv,12,25,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_26_CSVFormat,Csv,12,26,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_27_CSVFormat,Csv,12,27,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_28_CSVFormat,Csv,12,28,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_29_CSVFormat,Csv,12,29,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_30_CSVFormat,Csv,12,30,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_31_CSVFormat,Csv,12,31,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_32_CSVFormat,Csv,12,32,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_33_CSVFormat,Csv,12,33,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_34_CSVFormat,Csv,12,34,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_35_CSVFormat,Csv,12,35,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_36_CSVFormat,Csv,12,36,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_37_CSVFormat,Csv,12,37,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_12_38_CSVFormat,Csv,12,38,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); public static CSVFormat newFormat(char); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(true); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, String[], boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_0_CSVPrinter,Csv,13,0,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { @Override public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { @Override public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { @Override public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_1_CSVPrinter,Csv,13,1,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { @Override public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { @Override public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { @Override public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_2_CSVPrinter,Csv,13,2,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getObject(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getObject(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getObject(i)); } println(); } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_3_CSVFormat,Csv,13,3,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_4_CSVFormat,Csv,13,4,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_5_CSVFormat,Csv,13,5,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_6_CSVFormat,Csv,13,6,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>"
Csv_13_7_CSVFormat,Csv,13,7,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_8_CSVFormat,Csv,13,8,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_9_CSVFormat,Csv,13,9,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_10_CSVFormat,Csv,13,10,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_11_CSVFormat,Csv,13,11,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String[] headerComments; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String[] headerComments;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_12_CSVPrinter,Csv,13,12,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_13_CSVFormat,Csv,13,13,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_14_CSVFormat,Csv,13,14,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_15_CSVFormat,Csv,13,15,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_16_CSVFormat,Csv,13,16,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_17_CSVFormat,Csv,13,17,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_18_CSVFormat,Csv,13,18,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_19_CSVFormat,Csv,13,19,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_20_CSVFormat,Csv,13,20,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_21_CSVFormat,Csv,13,21,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_22_CSVFormat,Csv,13,22,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_23_CSVPrinter,Csv,13,23,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); private void print(Object, CharSequence, int, int); private final CSVFormat format; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getNullString(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private void print(Object, CharSequence, int, int); private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getNullString(); }</ECTX>"
Csv_13_24_CSVFormat,Csv,13,24,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_25_CSVFormat,Csv,13,25,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character escapeCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character escapeCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_26_CSVFormat,Csv,13,26,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String nullString; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String nullString;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_27_CSVFormat,Csv,13,27,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character quoteCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character quoteCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_28_CSVFormat,Csv,13,28,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_29_CSVFormat,Csv,13,29,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_30_CSVFormat,Csv,13,30,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_31_CSVFormat,Csv,13,31,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_32_CSVFormat,Csv,13,32,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_33_CSVFormat,Csv,13,33,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_34_CSVPrinter,Csv,13,34,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentMarkerSet()) { return; } if (!newRecord) { println(); } out.append(format.getCommentMarker().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentMarker().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentMarkerSet()) { return; } if (!newRecord) { println(); } out.append(format.getCommentMarker().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentMarker().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public boolean isCommentMarkerSet(); public Character getCommentMarker(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentMarkerSet()) { return; } if (!newRecord) { println(); } out.append(format.getCommentMarker().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentMarker().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public boolean isCommentMarkerSet(); public Character getCommentMarker(); } final class Constants { static final char CR = '\r'; static final char LF = '\n'; static final char SP = ' '; }</ECTX>"
Csv_13_35_CSVFormat,Csv,13,35,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_36_CSVFormat,Csv,13,36,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_37_CSVFormat,Csv,13,37,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_38_CSVFormat,Csv,13,38,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_39_CSVFormat,Csv,13,39,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_40_CSVFormat,Csv,13,40,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_41_CSVFormat,Csv,13,41,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_42_CSVFormat,Csv,13,42,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_43_CSVFormat,Csv,13,43,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_44_CSVFormat,Csv,13,44,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_45_CSVPrinter,Csv,13,45,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); private final Appendable out; private final CSVFormat format; private boolean newRecord = true; }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getRecordSeparator(); }</ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX>private final Appendable out; private final CSVFormat format; private boolean newRecord = true;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVFormat implements Serializable { public String getRecordSeparator(); }</ECTX>"
Csv_13_46_CSVFormat,Csv,13,46,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_47_CSVFormat,Csv,13,47,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_48_CSVFormat,Csv,13,48,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_49_CSVFormat,Csv,13,49,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_50_CSVFormat,Csv,13,50,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_51_CSVFormat,Csv,13,51,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_52_CSVFormat,Csv,13,52,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private static boolean isLineBreak(char); private final char delimiter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_53_CSVFormat,Csv,13,53,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_54_CSVFormat,Csv,13,54,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_55_CSVFormat,Csv,13,55,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_56_CSVPrinter,Csv,13,56,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_57_CSVFormat,Csv,13,57,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_58_CSVFormat,Csv,13,58,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.TAB;|import java.io.IOException;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getAllowMissingColumnNames(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreSurroundingSpaces(); public boolean getIgnoreHeaderCase(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @Override public String toString(); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withHeader(String); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeaderComments(Object); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean); private final char delimiter; private final Character quoteCharacter; private final QuoteMode quoteMode; private final Character commentMarker; private final Character escapeCharacter; private final boolean ignoreSurroundingSpaces; private final boolean allowMissingColumnNames; private final boolean ignoreEmptyLines; private final String recordSeparator; private final String nullString; private final String[] header; private final String[] headerComments; private final boolean skipHeaderRecord; private final boolean ignoreHeaderCase;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_59_CSVPrinter,Csv,13,59,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecord(final Object...values) throws IOException { for (final Object value : values) { print(value); } println(); } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_60_CSVPrinter,Csv,13,60,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_13_61_CSVPrinter,Csv,13,61,org.apache.commons.csv.CSVPrinter,CSVPrinter,src/main/java/org/apache/commons/csv/CSVPrinter.java,CSVPrinter_ESTest,org/apache/commons/csv/CSVPrinter_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.SP;|import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.sql.ResultSet;|import java.sql.SQLException;","CSVPrinter implements Flushable, Closeable { public void printRecords(final Object...values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); @Override public void close(); @Override public void flush(); public Appendable getOut(); public void print(Object); public void printComment(String); public void println(); public void printRecord(Iterable<?>); public void printRecord(Object); public void printRecords(Iterable<?>); public void printRecords(Object); public void printRecords(ResultSet); }","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object...values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); }</FCTX> <ECTX></ECTX>","<FCTX>CSVPrinter implements Flushable, Closeable { public void printRecords(final Object...values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } public CSVPrinter(Appendable, CSVFormat); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_0_CSVFormat,Csv,14,0,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final char delimiter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final char delimiter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_1_CSVFormat,Csv,14,1,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_2_CSVFormat,Csv,14,2,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_3_CSVFormat,Csv,14,3,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_4_CSVFormat,Csv,14,4,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_5_CSVFormat,Csv,14,5,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_6_CSVFormat,Csv,14,6,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_7_CSVFormat,Csv,14,7,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_8_CSVFormat,Csv,14,8,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_9_CSVFormat,Csv,14,9,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_10_CSVFormat,Csv,14,10,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_11_CSVFormat,Csv,14,11,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getTrim() { return trim; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_12_CSVFormat,Csv,14,12,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_13_CSVFormat,Csv,14,13,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_14_CSVFormat,Csv,14,14,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_15_CSVFormat,Csv,14,15,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character escapeCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character escapeCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_16_CSVFormat,Csv,14,16,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String nullString; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String nullString;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_17_CSVFormat,Csv,14,17,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character quoteCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character quoteCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_18_CSVFormat,Csv,14,18,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_19_CSVFormat,Csv,14,19,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_20_CSVFormat,Csv,14,20,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_21_CSVFormat,Csv,14,21,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Path out, Charset charset) throws IOException { return print(out.toFile(), charset); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Path out, Charset charset) throws IOException { return print(out.toFile(), charset); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Path out, Charset charset) throws IOException { return print(out.toFile(), charset); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_22_CSVFormat,Csv,14,22,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { charSequence = nullString == null ? Constants.EMPTY : nullString; } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { charSequence = nullString == null ? Constants.EMPTY : nullString; } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private CharSequence trim(CharSequence); private void print(Object, CharSequence, int, int, Appendable, boolean); private final String nullString; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { charSequence = nullString == null ? Constants.EMPTY : nullString; } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private CharSequence trim(CharSequence); private void print(Object, CharSequence, int, int, Appendable, boolean); private final String nullString; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_23_CSVFormat,Csv,14,23,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean trim; }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>"
Csv_14_24_CSVFormat,Csv,14,24,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_25_CSVFormat,Csv,14,25,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_26_CSVFormat,Csv,14,26,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_27_CSVFormat,Csv,14,27,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_28_CSVFormat,Csv,14,28,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_29_CSVFormat,Csv,14,29,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_30_CSVFormat,Csv,14,30,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_31_CSVFormat,Csv,14,31,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_32_CSVFormat,Csv,14,32,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_33_CSVFormat,Csv,14,33,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_34_CSVFormat,Csv,14,34,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_35_CSVFormat,Csv,14,35,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_36_CSVFormat,Csv,14,36,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_37_CSVFormat,Csv,14,37,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_38_CSVFormat,Csv,14,38,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_39_CSVFormat,Csv,14,39,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_40_CSVFormat,Csv,14,40,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_41_CSVFormat,Csv,14,41,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_42_CSVFormat,Csv,14,42,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_43_CSVFormat,Csv,14,43,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_44_CSVFormat,Csv,14,44,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_45_CSVFormat,Csv,14,45,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_46_CSVFormat,Csv,14,46,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_47_CSVFormat,Csv,14,47,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_48_CSVFormat,Csv,14,48,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_49_CSVFormat,Csv,14,49,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_50_CSVFormat,Csv,14,50,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_51_CSVFormat,Csv,14,51,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_52_CSVFormat,Csv,14,52,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_53_CSVFormat,Csv,14,53,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_54_CSVFormat,Csv,14,54,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_55_CSVFormat,Csv,14,55,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_56_CSVFormat,Csv,14,56,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_57_CSVFormat,Csv,14,57,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_58_CSVFormat,Csv,14,58,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_59_CSVFormat,Csv,14,59,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_60_CSVFormat,Csv,14,60,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_61_CSVFormat,Csv,14,61,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_62_CSVFormat,Csv,14,62,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_14_63_CSVFormat,Csv,14,63,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false) .withQuote(null).withRecordSeparator(LF).withNullString(""\\N""); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] headerComments; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean); private final String[] headerComments;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_0_CSVFormat,Csv,15,0,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final char delimiter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final char delimiter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_1_CSVFormat,Csv,15,1,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_2_CSVFormat,Csv,15,2,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_3_CSVFormat,Csv,15,3,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_4_CSVFormat,Csv,15,4,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_5_CSVFormat,Csv,15,5,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getNullString() { return nullString; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_6_CSVFormat,Csv,15,6,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_7_CSVFormat,Csv,15,7,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_8_CSVFormat,Csv,15,8,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_9_CSVFormat,Csv,15,9,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_10_CSVFormat,Csv,15,10,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_11_CSVFormat,Csv,15,11,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getTrim() { return trim; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_12_CSVFormat,Csv,15,12,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_13_CSVFormat,Csv,15,13,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getAutoFlush() { return autoFlush; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getAutoFlush() { return autoFlush; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getAutoFlush() { return autoFlush; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_14_CSVFormat,Csv,15,14,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_15_CSVFormat,Csv,15,15,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_16_CSVFormat,Csv,15,16,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character escapeCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character escapeCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_17_CSVFormat,Csv,15,17,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String nullString; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String nullString;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_18_CSVFormat,Csv,15,18,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character quoteCharacter; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character quoteCharacter;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_19_CSVFormat,Csv,15,19,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_20_CSVFormat,Csv,15,20,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_21_CSVFormat,Csv,15,21,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter printer() throws IOException { return new CSVPrinter(System.out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter printer() throws IOException { return new CSVPrinter(System.out, this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter printer() throws IOException { return new CSVPrinter(System.out, this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_22_CSVFormat,Csv,15,22,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, final Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, final Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @SuppressWarnings(""resource"") public CSVPrinter print(final File out, final Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_23_CSVFormat,Csv,15,23,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean trim; }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>","<FCTX>CSVFormat implements Serializable { public String format(final Object...values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class CSVPrinter implements Flushable, Closeable { public CSVPrinter(Appendable, CSVFormat); public void printRecord(Object); }</ECTX>"
Csv_15_24_CSVFormat,Csv,15,24,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVPrinter print(final Path out, final Charset charset) throws IOException { return print(Files.newBufferedWriter(out, charset)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Path out, final Charset charset) throws IOException { return print(Files.newBufferedWriter(out, charset)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVPrinter print(final Path out, final Charset charset) throws IOException { return print(Files.newBufferedWriter(out, charset)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_25_CSVFormat,Csv,15,25,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { if (null == nullString) { charSequence = EMPTY; } else { if (QuoteMode.ALL == quoteMode) { charSequence = quoteCharacter + nullString + quoteCharacter; } else { charSequence = nullString; } } } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { if (null == nullString) { charSequence = EMPTY; } else { if (QuoteMode.ALL == quoteMode) { charSequence = quoteCharacter + nullString + quoteCharacter; } else { charSequence = nullString; } } } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private CharSequence trim(CharSequence); private void print(Object, CharSequence, int, int, Appendable, boolean); private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final boolean trim; }</FCTX> <ECTX>final class Constants { static final String EMPTY = """"; }</ECTX>","<FCTX>CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { if (null == nullString) { charSequence = EMPTY; } else { if (QuoteMode.ALL == quoteMode) { charSequence = quoteCharacter + nullString + quoteCharacter; } else { charSequence = nullString; } } } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private CharSequence trim(CharSequence); private void print(Object, CharSequence, int, int, Appendable, boolean); private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final boolean trim;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Constants { static final String EMPTY = """"; }</ECTX>"
Csv_15_26_CSVFormat,Csv,15,26,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_27_CSVFormat,Csv,15,27,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object...values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_28_CSVFormat,Csv,15,28,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(""Delimiter=<"").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append(""Escape=<"").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append(""QuoteChar=<"").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append(""CommentStart=<"").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append(""NullString=<"").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append(""RecordSeparator=<"").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append("" EmptyLines:ignored""); } if (getIgnoreSurroundingSpaces()) { sb.append("" SurroundingSpaces:ignored""); } if (getIgnoreHeaderCase()) { sb.append("" IgnoreHeaderCase:ignored""); } sb.append("" SkipHeaderRecord:"").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append(""HeaderComments:"").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append(""Header:"").append(Arrays.toString(header)); } return sb.toString(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_29_CSVFormat,Csv,15,29,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_30_CSVFormat,Csv,15,30,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_31_CSVFormat,Csv,15,31,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final Character commentMarker;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_32_CSVFormat,Csv,15,32,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException(""The comment start marker character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_33_CSVFormat,Csv,15,33,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException(""The delimiter cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_34_CSVFormat,Csv,15,34,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_35_CSVFormat,Csv,15,35,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_36_CSVFormat,Csv,15,36,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException(""The escape character cannot be a line break""); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_37_CSVFormat,Csv,15,37,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_38_CSVFormat,Csv,15,38,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_39_CSVFormat,Csv,15,39,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_40_CSVFormat,Csv,15,40,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_41_CSVFormat,Csv,15,41,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeader(final String...header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_42_CSVFormat,Csv,15,42,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object...headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_43_CSVFormat,Csv,15,43,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_44_CSVFormat,Csv,15,44,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_45_CSVFormat,Csv,15,45,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_46_CSVFormat,Csv,15,46,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_47_CSVFormat,Csv,15,47,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_48_CSVFormat,Csv,15,48,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_49_CSVFormat,Csv,15,49,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_50_CSVFormat,Csv,15,50,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_51_CSVFormat,Csv,15,51,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_52_CSVFormat,Csv,15,52,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException(""The quoteChar cannot be a line break""); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private static boolean isLineBreak(char); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_53_CSVFormat,Csv,15,53,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_54_CSVFormat,Csv,15,54,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String recordSeparator; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String recordSeparator;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_55_CSVFormat,Csv,15,55,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_56_CSVFormat,Csv,15,56,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_57_CSVFormat,Csv,15,57,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_58_CSVFormat,Csv,15,58,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_59_CSVFormat,Csv,15,59,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_60_CSVFormat,Csv,15,60,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_61_CSVFormat,Csv,15,61,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_62_CSVFormat,Csv,15,62,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_63_CSVFormat,Csv,15,63,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public CSVFormat withAutoFlush(final boolean autoFlush) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public CSVFormat withAutoFlush(final boolean autoFlush) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public CSVFormat withAutoFlush(final boolean autoFlush) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final boolean allowMissingColumnNames; private final Character commentMarker; private final char delimiter; private final Character escapeCharacter; private final String[] header; private final String[] headerComments; private final boolean ignoreEmptyLines; private final boolean ignoreHeaderCase; private final boolean ignoreSurroundingSpaces; private final String nullString; private final Character quoteCharacter; private final QuoteMode quoteMode; private final String recordSeparator; private final boolean skipHeaderRecord; private final boolean trailingDelimiter; private final boolean trim; private final boolean autoFlush;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_64_CSVFormat,Csv,15,64,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_65_CSVFormat,Csv,15,65,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] header; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] header;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_15_66_CSVFormat,Csv,15,66,org.apache.commons.csv.CSVFormat,CSVFormat,src/main/java/org/apache/commons/csv/CSVFormat.java,CSVFormat_ESTest,org/apache/commons/csv/CSVFormat_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Constants.BACKSLASH;|import static org.apache.commons.csv.Constants.COMMA;|import static org.apache.commons.csv.Constants.COMMENT;|import static org.apache.commons.csv.Constants.EMPTY;|import static org.apache.commons.csv.Constants.CR;|import static org.apache.commons.csv.Constants.CRLF;|import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;|import static org.apache.commons.csv.Constants.LF;|import static org.apache.commons.csv.Constants.PIPE;|import static org.apache.commons.csv.Constants.SP;|import static org.apache.commons.csv.Constants.TAB;|import java.io.File;|import java.io.FileOutputStream;|import java.io.IOException;|import java.io.OutputStreamWriter;|import java.io.Reader;|import java.io.Serializable;|import java.io.StringWriter;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.sql.ResultSet;|import java.sql.ResultSetMetaData;|import java.sql.SQLException;|import java.util.Arrays;|import java.util.HashSet;|import java.util.Set;","CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); public static CSVFormat newFormat(char); public static CSVFormat valueOf(String); @Override public boolean equals(Object); public String format(Object); public boolean getAllowMissingColumnNames(); public Character getCommentMarker(); public char getDelimiter(); public Character getEscapeCharacter(); public String[] getHeader(); public String[] getHeaderComments(); public boolean getIgnoreEmptyLines(); public boolean getIgnoreHeaderCase(); public boolean getIgnoreSurroundingSpaces(); public String getNullString(); public Character getQuoteCharacter(); public QuoteMode getQuoteMode(); public String getRecordSeparator(); public boolean getSkipHeaderRecord(); public boolean getTrailingDelimiter(); public boolean getTrim(); public boolean getAutoFlush(); @Override public int hashCode(); public boolean isCommentMarkerSet(); public boolean isEscapeCharacterSet(); public boolean isNullStringSet(); public boolean isQuoteCharacterSet(); public CSVParser parse(Reader); public CSVPrinter print(Appendable); public CSVPrinter printer(); @SuppressWarnings(""resource"") public CSVPrinter print(File, Charset); public CSVPrinter print(Path, Charset); public void print(Object, Appendable, boolean); public void println(Appendable); public void printRecord(Appendable, Object); @Override public String toString(); public CSVFormat withAllowMissingColumnNames(); public CSVFormat withAllowMissingColumnNames(boolean); public CSVFormat withCommentMarker(char); public CSVFormat withCommentMarker(Character); public CSVFormat withDelimiter(char); public CSVFormat withEscape(char); public CSVFormat withEscape(Character); public CSVFormat withFirstRecordAsHeader(); public CSVFormat withHeader(Class<?extendsEnum<?>>); public CSVFormat withHeader(ResultSet); public CSVFormat withHeader(ResultSetMetaData); public CSVFormat withHeader(String); public CSVFormat withHeaderComments(Object); public CSVFormat withIgnoreEmptyLines(); public CSVFormat withIgnoreEmptyLines(boolean); public CSVFormat withIgnoreHeaderCase(); public CSVFormat withIgnoreHeaderCase(boolean); public CSVFormat withIgnoreSurroundingSpaces(); public CSVFormat withIgnoreSurroundingSpaces(boolean); public CSVFormat withNullString(String); public CSVFormat withQuote(char); public CSVFormat withQuote(Character); public CSVFormat withQuoteMode(QuoteMode); public CSVFormat withRecordSeparator(char); public CSVFormat withRecordSeparator(String); public CSVFormat withSkipHeaderRecord(); public CSVFormat withSkipHeaderRecord(boolean); public CSVFormat withTrailingDelimiter(); public CSVFormat withTrailingDelimiter(boolean); public CSVFormat withTrim(); public CSVFormat withTrim(boolean); public CSVFormat withAutoFlush(boolean); public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false); public static final CSVFormat EXCEL = DEFAULT .withIgnoreEmptyLines(false) .withAllowMissingColumnNames(); public static final CSVFormat INFORMIX_UNLOAD = DEFAULT .withDelimiter(PIPE) .withEscape(BACKSLASH) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT .withDelimiter(COMMA) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF); public static final CSVFormat MYSQL = DEFAULT .withDelimiter(TAB) .withEscape(BACKSLASH) .withIgnoreEmptyLines(false) .withQuote(null) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_CSV = DEFAULT .withDelimiter(COMMA) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(EMPTY) .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat POSTGRESQL_TEXT = DEFAULT .withDelimiter(TAB) .withEscape(DOUBLE_QUOTE_CHAR) .withIgnoreEmptyLines(false) .withQuote(DOUBLE_QUOTE_CHAR) .withRecordSeparator(LF) .withNullString(""\\N"") .withQuoteMode(QuoteMode.ALL_NON_NULL); public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false); public static final CSVFormat TDF = DEFAULT .withDelimiter(TAB) .withIgnoreSurroundingSpaces(); }","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] headerComments; }</FCTX> <ECTX></ECTX>","<FCTX>CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } <PRIVATE_FCTX>private CSVFormat(char, Character, QuoteMode, Character, Character, boolean, boolean, String, String, Object[], String[], boolean, boolean, boolean, boolean, boolean, boolean); private final String[] headerComments;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_16_0_CSVParser,Csv,16,0,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, ""file""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_16_1_CSVParser,Csv,16,1,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(inputStream, ""inputStream""); Assertions.notNull(format, ""format""); return parse(new InputStreamReader(inputStream, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(inputStream, ""inputStream""); Assertions.notNull(format, ""format""); return parse(new InputStreamReader(inputStream, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings(""resource"") public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(inputStream, ""inputStream""); Assertions.notNull(format, ""format""); return parse(new InputStreamReader(inputStream, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_16_2_CSVParser,Csv,16,2,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private long recordNumber; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private long recordNumber;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_16_3_CSVParser,Csv,16,3,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { CSVRecord rec; final List<CSVRecord> records = new ArrayList<>(); while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { CSVRecord rec; final List<CSVRecord> records = new ArrayList<>(); while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { CSVRecord rec; final List<CSVRecord> records = new ArrayList<>(); while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_16_4_CSVParser,Csv,16,4,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); boolean isClosed(); }</ECTX>"
Csv_16_5_CSVParser,Csv,16,5,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_16_6_CSVParser,Csv,16,6,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(path, ""path""); Assertions.notNull(format, ""format""); return parse(Files.newBufferedReader(path, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(path, ""path""); Assertions.notNull(format, ""format""); return parse(Files.newBufferedReader(path, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(path, ""path""); Assertions.notNull(format, ""format""); return parse(Files.newBufferedReader(path, charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_16_7_CSVParser,Csv,16,7,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException { return new CSVParser(reader, format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException { return new CSVParser(reader, format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException { return new CSVParser(reader, format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Csv_16_8_CSVParser,Csv,16,8,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, ""string""); Assertions.notNull(format, ""format""); return new CSVParser(new StringReader(string), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_16_9_CSVParser,Csv,16,9,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final CSVFormat format; }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, ""url""); Assertions.notNull(charset, ""charset""); Assertions.notNull(format, ""format""); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final CSVFormat format;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Assertions { public static void notNull(Object, String); }</ECTX>"
Csv_16_10_CSVParser,Csv,16,10,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { @Override public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @Override public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); @Override public void close(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { @Override public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); @Override public void close(); }</ECTX>"
Csv_16_11_CSVParser,Csv,16,11,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); long getCurrentLineNumber(); }</ECTX>"
Csv_16_12_CSVParser,Csv,16,12,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public String getFirstEndOfLine() { return lexer.getFirstEol(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public String getFirstEndOfLine() { return lexer.getFirstEol(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final Lexer lexer; }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); String getFirstEol(); }</ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public String getFirstEndOfLine() { return lexer.getFirstEol(); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final Lexer lexer;</PRIVATE_FCTX> }</FCTX> <ECTX>final class Lexer implements Closeable { Lexer(CSVFormat, ExtendedBufferedReader); String getFirstEol(); }</ECTX>"
Csv_16_13_CSVParser,Csv,16,13,org.apache.commons.csv.CSVParser,CSVParser,src/main/java/org/apache/commons/csv/CSVParser.java,CSVParser_ESTest,org/apache/commons/csv/CSVParser_ESTest.java,"package org.apache.commons.csv;","import static org.apache.commons.csv.Token.Type.TOKEN;|import java.io.Closeable;|import java.io.File;|import java.io.FileInputStream;|import java.io.IOException;|import java.io.InputStream;|import java.io.InputStreamReader;|import java.io.Reader;|import java.io.StringReader;|import java.net.URL;|import java.nio.charset.Charset;|import java.nio.file.Files;|import java.nio.file.Path;|import java.util.ArrayList;|import java.util.Arrays;|import java.util.Iterator;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.TreeMap;","CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); @SuppressWarnings(""resource"") public static CSVParser parse(File, Charset, CSVFormat); @SuppressWarnings(""resource"") public static CSVParser parse(InputStream, Charset, CSVFormat); public static CSVParser parse(Path, Charset, CSVFormat); public static CSVParser parse(Reader, CSVFormat); public static CSVParser parse(String, CSVFormat); public static CSVParser parse(URL, Charset, CSVFormat); @Override public void close(); public long getCurrentLineNumber(); public String getFirstEndOfLine(); public Map<String, Integer> getHeaderMap(); public long getRecordNumber(); public List<CSVRecord> getRecords(); public boolean isClosed(); @Override public Iterator<CSVRecord> iterator(); CSVRecord nextRecord(); }","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); private final Map<String, Integer> headerMap; }</FCTX> <ECTX></ECTX>","<FCTX>CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap); } public CSVParser(Reader, CSVFormat); @SuppressWarnings(""resource"") public CSVParser(Reader, CSVFormat, long, long); <PRIVATE_FCTX>private final Map<String, Integer> headerMap;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
