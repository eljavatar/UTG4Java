id,project,version,number_method_by_version,modified_class,focal_class,path_focal_class_in_project,test_class,path_test_class_scaffolding,package_focal_class,imports_focal_class,src_fm_fc_ms_ff,src_fm_fc_dctx,src_fm_fc_dctx_priv
Gson_1_0_TypeInfoFactory,Gson,1,0,com.google.gson.TypeInfoFactory,TypeInfoFactory,gson/src/main/java/com/google/gson/TypeInfoFactory.java,TypeInfoFactory_ESTest,com/google/gson/TypeInfoFactory_ESTest.java,"package com.google.gson;","import java.lang.reflect.Field;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;","TypeInfoFactory { public static TypeInfoArray getTypeInfoForArray(Type type) { Preconditions.checkArgument(TypeUtils.isArray(type)); return new TypeInfoArray(type); } private TypeInfoFactory(); public static TypeInfoArray getTypeInfoForArray(Type); public static TypeInfo getTypeInfoForField(Field, Type); }","<FCTX>TypeInfoFactory { public static TypeInfoArray getTypeInfoForArray(Type type) { Preconditions.checkArgument(TypeUtils.isArray(type)); return new TypeInfoArray(type); } private TypeInfoFactory(); }</FCTX> <ECTX>final class Preconditions { public static void checkArgument(boolean); } final class TypeUtils { static boolean isArray(Type); }</ECTX>","<FCTX>TypeInfoFactory { public static TypeInfoArray getTypeInfoForArray(Type type) { Preconditions.checkArgument(TypeUtils.isArray(type)); return new TypeInfoArray(type); } <PRIVATE_FCTX>private TypeInfoFactory();</PRIVATE_FCTX> }</FCTX> <ECTX>final class Preconditions { public static void checkArgument(boolean); } final class TypeUtils { static boolean isArray(Type); }</ECTX>"
Gson_1_1_TypeInfoFactory,Gson,1,1,com.google.gson.TypeInfoFactory,TypeInfoFactory,gson/src/main/java/com/google/gson/TypeInfoFactory.java,TypeInfoFactory_ESTest,com/google/gson/TypeInfoFactory_ESTest.java,"package com.google.gson;","import java.lang.reflect.Field;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;","TypeInfoFactory { public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); Type type = f.getGenericType(); Type actualType = getActualType(type, typeDefiningF, classDefiningF); return new TypeInfo(actualType); } private TypeInfoFactory(); public static TypeInfoArray getTypeInfoForArray(Type); public static TypeInfo getTypeInfoForField(Field, Type); }","<FCTX>TypeInfoFactory { public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); Type type = f.getGenericType(); Type actualType = getActualType(type, typeDefiningF, classDefiningF); return new TypeInfo(actualType); } private TypeInfoFactory(); private static Type getActualType(Type, Type, Class<?>); }</FCTX> <ECTX>final class TypeUtils { static Class<?> toRawClass(Type); }</ECTX>","<FCTX>TypeInfoFactory { public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); Type type = f.getGenericType(); Type actualType = getActualType(type, typeDefiningF, classDefiningF); return new TypeInfo(actualType); } <PRIVATE_FCTX>private TypeInfoFactory(); private static Type getActualType(Type, Type, Class<?>);</PRIVATE_FCTX> }</FCTX> <ECTX>final class TypeUtils { static Class<?> toRawClass(Type); }</ECTX>"
Gson_2_0_TypeAdapters,Gson,2,0,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_2_1_TypeAdapters,Gson,2,1,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_2_2_TypeAdapters,Gson,2,2,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_2_3_TypeAdapters,Gson,2,3,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;","TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_2_4_TypeAdapters,Gson,2,4,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;","TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { if (value == null) { out.nullValue(); return; } out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>"
Gson_3_0_ConstructorConstructor,Gson,3,0,com.google.gson.internal.ConstructorConstructor,ConstructorConstructor,gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java,ConstructorConstructor_ESTest,com/google/gson/internal/ConstructorConstructor_ESTest.java,"package com.google.gson.internal;","import java.lang.reflect.Constructor;|import java.lang.reflect.InvocationTargetException;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.util.ArrayList;|import java.util.Collection;|import java.util.EnumSet;|import java.util.LinkedHashMap;|import java.util.LinkedHashSet;|import java.util.LinkedList;|import java.util.Map;|import java.util.Queue;|import java.util.Set;|import java.util.SortedMap;|import java.util.SortedSet;|import java.util.TreeMap;|import java.util.TreeSet;|import java.util.concurrent.ConcurrentHashMap;|import java.util.concurrent.ConcurrentMap;|import java.util.concurrent.ConcurrentNavigableMap;|import java.util.concurrent.ConcurrentSkipListMap;|import com.google.gson.InstanceCreator;|import com.google.gson.JsonIOException;|import com.google.gson.reflect.TypeToken;","ConstructorConstructor { public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) { final Type type = typeToken.getType(); final Class<? super T> rawType = typeToken.getRawType(); @SuppressWarnings(""unchecked"") final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type); if (typeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return typeCreator.createInstance(type); } }; } @SuppressWarnings(""unchecked"") final InstanceCreator<T> rawTypeCreator = (InstanceCreator<T>) instanceCreators.get(rawType); if (rawTypeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return rawTypeCreator.createInstance(type); } }; } ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType); if (defaultConstructor != null) { return defaultConstructor; } ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType); if (defaultImplementation != null) { return defaultImplementation; } return newUnsafeAllocator(type, rawType); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); public <T> ObjectConstructor<T> get(TypeToken<T>); @Override public String toString(); }","<FCTX>ConstructorConstructor { public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) { final Type type = typeToken.getType(); final Class<? super T> rawType = typeToken.getRawType(); @SuppressWarnings(""unchecked"") final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type); if (typeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return typeCreator.createInstance(type); } }; } @SuppressWarnings(""unchecked"") final InstanceCreator<T> rawTypeCreator = (InstanceCreator<T>) instanceCreators.get(rawType); if (rawTypeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return rawTypeCreator.createInstance(type); } }; } ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType); if (defaultConstructor != null) { return defaultConstructor; } ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType); if (defaultImplementation != null) { return defaultImplementation; } return newUnsafeAllocator(type, rawType); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); private <T> ObjectConstructor<T> newDefaultConstructor(Class<?superT>); @SuppressWarnings(""unchecked"") private <T> ObjectConstructor<T> newDefaultImplementationConstructor(Type, Class<?superT>); private <T> ObjectConstructor<T> newUnsafeAllocator(Type, Class<?superT>); private final Map<Type, InstanceCreator<?>> instanceCreators; }</FCTX> <ECTX>public interface InstanceCreator<T> { public T createInstance(Type); } public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Type getType(); public final Class<? super T> getRawType(); }</ECTX>","<FCTX>ConstructorConstructor { public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) { final Type type = typeToken.getType(); final Class<? super T> rawType = typeToken.getRawType(); @SuppressWarnings(""unchecked"") final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type); if (typeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return typeCreator.createInstance(type); } }; } @SuppressWarnings(""unchecked"") final InstanceCreator<T> rawTypeCreator = (InstanceCreator<T>) instanceCreators.get(rawType); if (rawTypeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return rawTypeCreator.createInstance(type); } }; } ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType); if (defaultConstructor != null) { return defaultConstructor; } ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType); if (defaultImplementation != null) { return defaultImplementation; } return newUnsafeAllocator(type, rawType); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); <PRIVATE_FCTX>private <T> ObjectConstructor<T> newDefaultConstructor(Class<?superT>); @SuppressWarnings(""unchecked"") private <T> ObjectConstructor<T> newDefaultImplementationConstructor(Type, Class<?superT>); private <T> ObjectConstructor<T> newUnsafeAllocator(Type, Class<?superT>); private final Map<Type, InstanceCreator<?>> instanceCreators;</PRIVATE_FCTX> }</FCTX> <ECTX>public interface InstanceCreator<T> { public T createInstance(Type); } public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Type getType(); public final Class<? super T> getRawType(); }</ECTX>"
Gson_3_1_ConstructorConstructor,Gson,3,1,com.google.gson.internal.ConstructorConstructor,ConstructorConstructor,gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java,ConstructorConstructor_ESTest,com/google/gson/internal/ConstructorConstructor_ESTest.java,"package com.google.gson.internal;","import java.lang.reflect.Constructor;|import java.lang.reflect.InvocationTargetException;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.util.ArrayList;|import java.util.Collection;|import java.util.EnumSet;|import java.util.LinkedHashMap;|import java.util.LinkedHashSet;|import java.util.LinkedList;|import java.util.Map;|import java.util.Queue;|import java.util.Set;|import java.util.SortedMap;|import java.util.SortedSet;|import java.util.TreeMap;|import java.util.TreeSet;|import java.util.concurrent.ConcurrentHashMap;|import java.util.concurrent.ConcurrentMap;|import java.util.concurrent.ConcurrentNavigableMap;|import java.util.concurrent.ConcurrentSkipListMap;|import com.google.gson.InstanceCreator;|import com.google.gson.JsonIOException;|import com.google.gson.reflect.TypeToken;","ConstructorConstructor { @Override public String toString() { return instanceCreators.toString(); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); public <T> ObjectConstructor<T> get(TypeToken<T>); @Override public String toString(); }","<FCTX>ConstructorConstructor { @Override public String toString() { return instanceCreators.toString(); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); private final Map<Type, InstanceCreator<?>> instanceCreators; }</FCTX> <ECTX></ECTX>","<FCTX>ConstructorConstructor { @Override public String toString() { return instanceCreators.toString(); } public ConstructorConstructor(Map<Type,InstanceCreator<?>>); <PRIVATE_FCTX>private final Map<Type, InstanceCreator<?>> instanceCreators;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_0_JsonReader,Gson,4,0,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_1_JsonReader,Gson,4,1,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_2_JsonReader,Gson,4,2,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_3_JsonReader,Gson,4,3,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_4_JsonReader,Gson,4,4,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_5_JsonReader,Gson,4,5,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_6_JsonReader,Gson,4,6,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_7_JsonReader,Gson,4,7,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_8_JsonReader,Gson,4,8,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_9_JsonReader,Gson,4,9,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_10_JsonReader,Gson,4,10,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); <PRIVATE_FCTX>private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_11_JsonWriter,Gson,4,11,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); private String indent; private String separator = "":""; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); <PRIVATE_FCTX>private String indent; private String separator = "":"";</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_12_JsonReader,Gson,4,12,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_13_JsonWriter,Gson,4,13,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_14_JsonWriter,Gson,4,14,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_15_JsonWriter,Gson,4,15,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_16_JsonWriter,Gson,4,16,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_17_JsonWriter,Gson,4,17,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_18_JsonWriter,Gson,4,18,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_19_JsonWriter,Gson,4,19,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>"
Gson_4_20_JsonWriter,Gson,4,20,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>"
Gson_4_21_JsonWriter,Gson,4,21,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>"
Gson_4_22_JsonWriter,Gson,4,22,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>"
Gson_4_23_JsonReader,Gson,4,23,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_24_JsonWriter,Gson,4,24,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); private int stackSize = 0; private String deferredName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private int stackSize = 0; private String deferredName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_25_JsonWriter,Gson,4,25,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_26_JsonWriter,Gson,4,26,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_27_JsonWriter,Gson,4,27,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_28_JsonWriter,Gson,4,28,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_29_JsonWriter,Gson,4,29,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_30_JsonWriter,Gson,4,30,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_31_JsonWriter,Gson,4,31,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_32_JsonWriter,Gson,4,32,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); private final Writer out; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_33_JsonWriter,Gson,4,33,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); private final Writer out; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>"
Gson_4_34_JsonReader,Gson,4,34,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_35_JsonReader,Gson,4,35,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_36_JsonReader,Gson,4,36,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_37_JsonReader,Gson,4,37,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_38_JsonReader,Gson,4,38,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_4_39_JsonReader,Gson,4,39,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_5_0_ISO8601Utils,Gson,5,0,com.google.gson.internal.bind.util.ISO8601Utils,ISO8601Utils,gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java,ISO8601Utils_ESTest,com/google/gson/internal/bind/util/ISO8601Utils_ESTest.java,"package com.google.gson.internal.bind.util;","import java.text.ParseException;|import java.text.ParsePosition;|import java.util.*;","ISO8601Utils { public static String format(Date date) { return format(date, false, TIMEZONE_UTC); } public static String format(Date); public static String format(Date, boolean); public static String format(Date, boolean, TimeZone); public static Date parse(String, ParsePosition); }","<FCTX>ISO8601Utils { public static String format(Date date) { return format(date, false, TIMEZONE_UTC); } private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID); }</FCTX> <ECTX></ECTX>","<FCTX>ISO8601Utils { public static String format(Date date) { return format(date, false, TIMEZONE_UTC); } <PRIVATE_FCTX>private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_5_1_ISO8601Utils,Gson,5,1,com.google.gson.internal.bind.util.ISO8601Utils,ISO8601Utils,gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java,ISO8601Utils_ESTest,com/google/gson/internal/bind/util/ISO8601Utils_ESTest.java,"package com.google.gson.internal.bind.util;","import java.text.ParseException;|import java.text.ParsePosition;|import java.util.*;","ISO8601Utils { public static String format(Date date, boolean millis) { return format(date, millis, TIMEZONE_UTC); } public static String format(Date); public static String format(Date, boolean); public static String format(Date, boolean, TimeZone); public static Date parse(String, ParsePosition); }","<FCTX>ISO8601Utils { public static String format(Date date, boolean millis) { return format(date, millis, TIMEZONE_UTC); } private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID); }</FCTX> <ECTX></ECTX>","<FCTX>ISO8601Utils { public static String format(Date date, boolean millis) { return format(date, millis, TIMEZONE_UTC); } <PRIVATE_FCTX>private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_5_2_ISO8601Utils,Gson,5,2,com.google.gson.internal.bind.util.ISO8601Utils,ISO8601Utils,gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java,ISO8601Utils_ESTest,com/google/gson/internal/bind/util/ISO8601Utils_ESTest.java,"package com.google.gson.internal.bind.util;","import java.text.ParseException;|import java.text.ParsePosition;|import java.util.*;","ISO8601Utils { public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = ""yyyy-MM-ddThh:mm:ss"".length(); capacity += millis ? "".sss"".length() : 0; capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, ""hh"".length()); formatted.append(':'); padInt(formatted, minutes, ""mm"".length()); } else { formatted.append('Z'); } return formatted.toString(); } public static String format(Date); public static String format(Date, boolean); public static String format(Date, boolean, TimeZone); public static Date parse(String, ParsePosition); }","<FCTX>ISO8601Utils { public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = ""yyyy-MM-ddThh:mm:ss"".length(); capacity += millis ? "".sss"".length() : 0; capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, ""hh"".length()); formatted.append(':'); padInt(formatted, minutes, ""mm"".length()); } else { formatted.append('Z'); } return formatted.toString(); } private static void padInt(StringBuilder, int, int); }</FCTX> <ECTX></ECTX>","<FCTX>ISO8601Utils { public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = ""yyyy-MM-ddThh:mm:ss"".length(); capacity += millis ? "".sss"".length() : 0; capacity += tz.getRawOffset() == 0 ? ""Z"".length() : ""+hh:mm"".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), ""yyyy"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, ""MM"".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), ""dd"".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), ""hh"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), ""mm"".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), ""ss"".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), ""sss"".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, ""hh"".length()); formatted.append(':'); padInt(formatted, minutes, ""mm"".length()); } else { formatted.append('Z'); } return formatted.toString(); } <PRIVATE_FCTX>private static void padInt(StringBuilder, int, int);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_5_3_ISO8601Utils,Gson,5,3,com.google.gson.internal.bind.util.ISO8601Utils,ISO8601Utils,gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java,ISO8601Utils_ESTest,com/google/gson/internal/bind/util/ISO8601Utils_ESTest.java,"package com.google.gson.internal.bind.util;","import java.text.ParseException;|import java.text.ParsePosition;|import java.util.*;","ISO8601Utils { public static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; boolean hasT = checkOffset(date, offset, 'T'); if (!hasT && (date.length() <= offset)) { Calendar calendar = new GregorianCalendar(year, month - 1, day); pos.setIndex(offset); return calendar.getTime(); } if (hasT) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (seconds > 59 && seconds < 63) seconds = 59; if (checkOffset(date, offset, '.')) { offset += 1; int endOffset = indexOfNonDigit(date, offset + 1); int parseEndOffset = Math.min(endOffset, offset + 3); int fraction = parseInt(date, offset, parseEndOffset); switch (parseEndOffset - offset) { case 2: milliseconds = fraction * 10; break; case 1: milliseconds = fraction * 100; break; default: milliseconds = fraction; } offset = endOffset; } } } } if (date.length() <= offset) { throw new IllegalArgumentException(""No time zone indicator""); } TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + ""00""; offset += timezoneOffset.length(); if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId = ""GMT"" + timezoneOffset; timezone = TimeZone.getTimeZone(timezoneId); String act = timezone.getID(); if (!act.equals(timezoneId)) { String cleaned = act.replace("":"", """"); if (!cleaned.equals(timezoneId)) { throw new IndexOutOfBoundsException(""Mismatching time zone indicator: ""+timezoneId+"" given, resolves to "" +timezone.getID()); } } } } else { throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator+""'""); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('""' + date + ""'""); String msg = fail.getMessage(); if (msg == null || msg.isEmpty()) { msg = ""(""+fail.getClass().getName()+"")""; } ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex()); ex.initCause(fail); throw ex; } public static String format(Date); public static String format(Date, boolean); public static String format(Date, boolean, TimeZone); public static Date parse(String, ParsePosition); }","<FCTX>ISO8601Utils { public static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; boolean hasT = checkOffset(date, offset, 'T'); if (!hasT && (date.length() <= offset)) { Calendar calendar = new GregorianCalendar(year, month - 1, day); pos.setIndex(offset); return calendar.getTime(); } if (hasT) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (seconds > 59 && seconds < 63) seconds = 59; if (checkOffset(date, offset, '.')) { offset += 1; int endOffset = indexOfNonDigit(date, offset + 1); int parseEndOffset = Math.min(endOffset, offset + 3); int fraction = parseInt(date, offset, parseEndOffset); switch (parseEndOffset - offset) { case 2: milliseconds = fraction * 10; break; case 1: milliseconds = fraction * 100; break; default: milliseconds = fraction; } offset = endOffset; } } } } if (date.length() <= offset) { throw new IllegalArgumentException(""No time zone indicator""); } TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + ""00""; offset += timezoneOffset.length(); if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId = ""GMT"" + timezoneOffset; timezone = TimeZone.getTimeZone(timezoneId); String act = timezone.getID(); if (!act.equals(timezoneId)) { String cleaned = act.replace("":"", """"); if (!cleaned.equals(timezoneId)) { throw new IndexOutOfBoundsException(""Mismatching time zone indicator: ""+timezoneId+"" given, resolves to "" +timezone.getID()); } } } } else { throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator+""'""); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('""' + date + ""'""); String msg = fail.getMessage(); if (msg == null || msg.isEmpty()) { msg = ""(""+fail.getClass().getName()+"")""; } ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex()); ex.initCause(fail); throw ex; } private static int parseInt(String, int, int); private static boolean checkOffset(String, int, char); private static int indexOfNonDigit(String, int); private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID); }</FCTX> <ECTX></ECTX>","<FCTX>ISO8601Utils { public static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; boolean hasT = checkOffset(date, offset, 'T'); if (!hasT && (date.length() <= offset)) { Calendar calendar = new GregorianCalendar(year, month - 1, day); pos.setIndex(offset); return calendar.getTime(); } if (hasT) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (seconds > 59 && seconds < 63) seconds = 59; if (checkOffset(date, offset, '.')) { offset += 1; int endOffset = indexOfNonDigit(date, offset + 1); int parseEndOffset = Math.min(endOffset, offset + 3); int fraction = parseInt(date, offset, parseEndOffset); switch (parseEndOffset - offset) { case 2: milliseconds = fraction * 10; break; case 1: milliseconds = fraction * 100; break; default: milliseconds = fraction; } offset = endOffset; } } } } if (date.length() <= offset) { throw new IllegalArgumentException(""No time zone indicator""); } TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + ""00""; offset += timezoneOffset.length(); if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId = ""GMT"" + timezoneOffset; timezone = TimeZone.getTimeZone(timezoneId); String act = timezone.getID(); if (!act.equals(timezoneId)) { String cleaned = act.replace("":"", """"); if (!cleaned.equals(timezoneId)) { throw new IndexOutOfBoundsException(""Mismatching time zone indicator: ""+timezoneId+"" given, resolves to "" +timezone.getID()); } } } } else { throw new IndexOutOfBoundsException(""Invalid time zone indicator '"" + timezoneIndicator+""'""); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('""' + date + ""'""); String msg = fail.getMessage(); if (msg == null || msg.isEmpty()) { msg = ""(""+fail.getClass().getName()+"")""; } ParseException ex = new ParseException(""Failed to parse date ["" + input + ""]: "" + msg, pos.getIndex()); ex.initCause(fail); throw ex; } <PRIVATE_FCTX>private static int parseInt(String, int, int); private static boolean checkOffset(String, int, char); private static int indexOfNonDigit(String, int); private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_6_0_JsonAdapterAnnotationTypeAdapterFactory,Gson,6,0,com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory,JsonAdapterAnnotationTypeAdapterFactory,gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java,JsonAdapterAnnotationTypeAdapterFactory_ESTest,com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.Gson;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.JsonAdapter;|import com.google.gson.internal.ConstructorConstructor;|import com.google.gson.reflect.TypeToken;","JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) { JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class); if (annotation == null) { return null; } return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation); } public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor); @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson, TypeToken<T>); @SuppressWarnings(""unchecked"") static TypeAdapter<?> getTypeAdapter(ConstructorConstructor, Gson, TypeToken<?>, JsonAdapter); }","<FCTX>JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) { JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class); if (annotation == null) { return null; } return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation); } public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor); private final ConstructorConstructor constructorConstructor; }</FCTX> <ECTX>public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Class<? super T> getRawType(); }</ECTX>","<FCTX>JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) { JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class); if (annotation == null) { return null; } return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation); } public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor); <PRIVATE_FCTX>private final ConstructorConstructor constructorConstructor;</PRIVATE_FCTX> }</FCTX> <ECTX>public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Class<? super T> getRawType(); }</ECTX>"
Gson_7_0_JsonReader,Gson,7,0,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_1_JsonReader,Gson,7,1,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_2_JsonReader,Gson,7,2,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_3_JsonReader,Gson,7,3,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_4_JsonReader,Gson,7,4,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_5_JsonReader,Gson,7,5,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_6_JsonReader,Gson,7,6,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_7_JsonReader,Gson,7,7,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_8_JsonReader,Gson,7,8,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_9_JsonReader,Gson,7,9,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber(); } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_10_JsonReader,Gson,7,10,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); <PRIVATE_FCTX>private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_11_JsonReader,Gson,7,11,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_12_JsonReader,Gson,7,12,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_13_JsonReader,Gson,7,13,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_14_JsonReader,Gson,7,14,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_15_JsonReader,Gson,7,15,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_16_JsonReader,Gson,7,16,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_17_JsonReader,Gson,7,17,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_7_18_JsonReader,Gson,7,18,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); int getLineNumber(); int getColumnNumber(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_8_0_UnsafeAllocator,Gson,8,0,com.google.gson.internal.UnsafeAllocator,UnsafeAllocator,gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java,UnsafeAllocator_ESTest,com/google/gson/internal/UnsafeAllocator_ESTest.java,"package com.google.gson.internal;","import java.io.ObjectInputStream;|import java.io.ObjectStreamClass;|import java.lang.reflect.Field;|import java.lang.reflect.Method;|import java.lang.reflect.Modifier;","UnsafeAllocator { public abstract <T> T newInstance(Class<T> c) throws Exception; public abstract <T> T newInstance(Class<T>); public static UnsafeAllocator create(); }","<FCTX>UnsafeAllocator { public abstract <T> T newInstance(Class<T> c) throws Exception; }</FCTX> <ECTX></ECTX>","<FCTX>UnsafeAllocator { public abstract <T> T newInstance(Class<T> c) throws Exception; <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_8_1_UnsafeAllocator,Gson,8,1,com.google.gson.internal.UnsafeAllocator,UnsafeAllocator,gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java,UnsafeAllocator_ESTest,com/google/gson/internal/UnsafeAllocator_ESTest.java,"package com.google.gson.internal;","import java.io.ObjectInputStream;|import java.io.ObjectStreamClass;|import java.lang.reflect.Field;|import java.lang.reflect.Method;|import java.lang.reflect.Modifier;","UnsafeAllocator { public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe""); Field f = unsafeClass.getDeclaredField(""theUnsafe""); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod(""getConstructorId"", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class.getDeclaredMethod(""newInstance"", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class.getDeclaredMethod(""newInstance"", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException(""Cannot allocate "" + c); } }; } public abstract <T> T newInstance(Class<T>); public static UnsafeAllocator create(); }","<FCTX>UnsafeAllocator { public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe""); Field f = unsafeClass.getDeclaredField(""theUnsafe""); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod(""getConstructorId"", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class.getDeclaredMethod(""newInstance"", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class.getDeclaredMethod(""newInstance"", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException(""Cannot allocate "" + c); } }; } private static void assertInstantiable(Class<?>); }</FCTX> <ECTX></ECTX>","<FCTX>UnsafeAllocator { public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe""); Field f = unsafeClass.getDeclaredField(""theUnsafe""); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod(""getConstructorId"", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class.getDeclaredMethod(""newInstance"", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class.getDeclaredMethod(""newInstance"", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(""unchecked"") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException(""Cannot allocate "" + c); } }; } <PRIVATE_FCTX>private static void assertInstantiable(Class<?>);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_0_TypeAdapters,Gson,9,0,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_1_TypeAdapters,Gson,9,1,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_2_JsonWriter,Gson,9,2,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_3_JsonWriter,Gson,9,3,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_4_JsonWriter,Gson,9,4,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>"
Gson_9_5_JsonWriter,Gson,9,5,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>"
Gson_9_6_JsonWriter,Gson,9,6,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>"
Gson_9_7_JsonWriter,Gson,9,7,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>"
Gson_9_8_JsonWriter,Gson,9,8,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); private int stackSize = 0; private String deferredName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private int stackSize = 0; private String deferredName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_9_JsonWriter,Gson,9,9,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_10_JsonWriter,Gson,9,10,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_11_JsonWriter,Gson,9,11,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_12_TypeAdapters,Gson,9,12,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_13_JsonWriter,Gson,9,13,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_14_JsonWriter,Gson,9,14,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_15_JsonWriter,Gson,9,15,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_16_JsonWriter,Gson,9,16,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_17_JsonWriter,Gson,9,17,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_18_JsonWriter,Gson,9,18,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); private final Writer out; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_19_JsonWriter,Gson,9,19,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); private final Writer out; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>"
Gson_9_20_JsonTreeWriter,Gson,9,20,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { public JsonElement get() { if (!stack.isEmpty()) { throw new IllegalStateException(""Expected one JSON element but was "" + stack); } return product; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { public JsonElement get() { if (!stack.isEmpty()) { throw new IllegalStateException(""Expected one JSON element but was "" + stack); } return product; } public JsonTreeWriter(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { public JsonElement get() { if (!stack.isEmpty()) { throw new IllegalStateException(""Expected one JSON element but was "" + stack); } return product; } public JsonTreeWriter(); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_21_JsonTreeWriter,Gson,9,21,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginArray() throws IOException { JsonArray array = new JsonArray(); put(array); stack.add(array); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginArray() throws IOException { JsonArray array = new JsonArray(); put(array); stack.add(array); return this; } public JsonTreeWriter(); private void put(JsonElement); private final List<JsonElement> stack = new ArrayList<JsonElement>(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginArray() throws IOException { JsonArray array = new JsonArray(); put(array); stack.add(array); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement); private final List<JsonElement> stack = new ArrayList<JsonElement>();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_22_JsonTreeWriter,Gson,9,22,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter endArray() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonArray) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter endArray() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonArray) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter endArray() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonArray) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); <PRIVATE_FCTX>private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_23_TypeAdapters,Gson,9,23,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_24_JsonTreeWriter,Gson,9,24,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginObject() throws IOException { JsonObject object = new JsonObject(); put(object); stack.add(object); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginObject() throws IOException { JsonObject object = new JsonObject(); put(object); stack.add(object); return this; } public JsonTreeWriter(); private void put(JsonElement); private final List<JsonElement> stack = new ArrayList<JsonElement>(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginObject() throws IOException { JsonObject object = new JsonObject(); put(object); stack.add(object); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement); private final List<JsonElement> stack = new ArrayList<JsonElement>();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_25_JsonTreeWriter,Gson,9,25,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter endObject() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter endObject() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter endObject() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } public JsonTreeWriter(); <PRIVATE_FCTX>private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_26_JsonTreeWriter,Gson,9,26,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter name(String name) throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { pendingName = name; return this; } throw new IllegalStateException(); } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter name(String name) throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { pendingName = name; return this; } throw new IllegalStateException(); } public JsonTreeWriter(); private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter name(String name) throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { pendingName = name; return this; } throw new IllegalStateException(); } public JsonTreeWriter(); <PRIVATE_FCTX>private JsonElement peek(); private final List<JsonElement> stack = new ArrayList<JsonElement>(); private String pendingName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_27_JsonTreeWriter,Gson,9,27,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_28_JsonTreeWriter,Gson,9,28,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter nullValue() throws IOException { put(JsonNull.INSTANCE); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter nullValue() throws IOException { put(JsonNull.INSTANCE); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX>public final class JsonNull extends JsonElement { public static final JsonNull INSTANCE = new JsonNull(); @Deprecated public JsonNull(); }</ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter nullValue() throws IOException { put(JsonNull.INSTANCE); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX>public final class JsonNull extends JsonElement { public static final JsonNull INSTANCE = new JsonNull(); @Deprecated public JsonNull(); }</ECTX>"
Gson_9_29_JsonTreeWriter,Gson,9,29,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(boolean value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(boolean value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(boolean value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_30_JsonTreeWriter,Gson,9,30,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_31_JsonTreeWriter,Gson,9,31,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_32_JsonTreeWriter,Gson,9,32,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(long value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(long value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(long value) throws IOException { put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_33_JsonTreeWriter,Gson,9,33,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } if (!isLenient()) { double d = value.doubleValue(); if (Double.isNaN(d) || Double.isInfinite(d)) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } if (!isLenient()) { double d = value.doubleValue(); if (Double.isNaN(d) || Double.isInfinite(d)) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); private void put(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } if (!isLenient()) { double d = value.doubleValue(); if (Double.isNaN(d) || Double.isInfinite(d)) { throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value); } } put(new JsonPrimitive(value)); return this; } public JsonTreeWriter(); <PRIVATE_FCTX>private void put(JsonElement);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_34_TypeAdapters,Gson,9,34,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>"
Gson_9_35_JsonTreeWriter,Gson,9,35,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public void flush() throws IOException { } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public void flush() throws IOException { } public JsonTreeWriter(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public void flush() throws IOException { } public JsonTreeWriter(); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_36_JsonTreeWriter,Gson,9,36,com.google.gson.internal.bind.JsonTreeWriter,JsonTreeWriter,gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,JsonTreeWriter_ESTest,com/google/gson/internal/bind/JsonTreeWriter_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.io.Writer;|import java.util.ArrayList;|import java.util.List;","JsonTreeWriter extends JsonWriter { @Override public void close() throws IOException { if (!stack.isEmpty()) { throw new IOException(""Incomplete document""); } stack.add(SENTINEL_CLOSED); } public JsonTreeWriter(); public JsonElement get(); @Override public JsonWriter beginArray(); @Override public JsonWriter endArray(); @Override public JsonWriter beginObject(); @Override public JsonWriter endObject(); @Override public JsonWriter name(String); @Override public JsonWriter value(String); @Override public JsonWriter nullValue(); @Override public JsonWriter value(boolean); @Override public JsonWriter value(Boolean); @Override public JsonWriter value(double); @Override public JsonWriter value(long); @Override public JsonWriter value(Number); @Override public void flush(); @Override public void close(); }","<FCTX>JsonTreeWriter extends JsonWriter { @Override public void close() throws IOException { if (!stack.isEmpty()) { throw new IOException(""Incomplete document""); } stack.add(SENTINEL_CLOSED); } public JsonTreeWriter(); private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(""closed""); private final List<JsonElement> stack = new ArrayList<JsonElement>(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeWriter extends JsonWriter { @Override public void close() throws IOException { if (!stack.isEmpty()) { throw new IOException(""Incomplete document""); } stack.add(SENTINEL_CLOSED); } public JsonTreeWriter(); <PRIVATE_FCTX>private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(""closed""); private final List<JsonElement> stack = new ArrayList<JsonElement>();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_37_JsonWriter,Gson,9,37,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); private String indent; private String separator = "":""; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); <PRIVATE_FCTX>private String indent; private String separator = "":"";</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_38_JsonWriter,Gson,9,38,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_39_JsonWriter,Gson,9,39,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_40_JsonWriter,Gson,9,40,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_9_41_JsonWriter,Gson,9,41,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_10_0_ReflectiveTypeAdapterFactory,Gson,10,0,com.google.gson.internal.bind.ReflectiveTypeAdapterFactory,ReflectiveTypeAdapterFactory,gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java,ReflectiveTypeAdapterFactory_ESTest,com/google/gson/internal/bind/ReflectiveTypeAdapterFactory_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.FieldNamingStrategy;|import com.google.gson.Gson;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.JsonAdapter;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.$Gson$Types;|import com.google.gson.internal.ConstructorConstructor;|import com.google.gson.internal.Excluder;|import com.google.gson.internal.ObjectConstructor;|import com.google.gson.internal.Primitives;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.lang.reflect.Field;|import java.lang.reflect.Type;|import java.util.ArrayList;|import java.util.Collections;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;","ReflectiveTypeAdapterFactory implements TypeAdapterFactory { public boolean excludeField(Field f, boolean serialize) { return excludeField(f, serialize, excluder); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); public boolean excludeField(Field, boolean); static boolean excludeField(Field, boolean, Excluder); @Override public <T> TypeAdapter<T> create(Gson, TypeToken<T>); }","<FCTX>ReflectiveTypeAdapterFactory implements TypeAdapterFactory { public boolean excludeField(Field f, boolean serialize) { return excludeField(f, serialize, excluder); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); private final Excluder excluder; }</FCTX> <ECTX></ECTX>","<FCTX>ReflectiveTypeAdapterFactory implements TypeAdapterFactory { public boolean excludeField(Field f, boolean serialize) { return excludeField(f, serialize, excluder); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); <PRIVATE_FCTX>private final Excluder excluder;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_10_1_ReflectiveTypeAdapterFactory,Gson,10,1,com.google.gson.internal.bind.ReflectiveTypeAdapterFactory,ReflectiveTypeAdapterFactory,gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java,ReflectiveTypeAdapterFactory_ESTest,com/google/gson/internal/bind/ReflectiveTypeAdapterFactory_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.FieldNamingStrategy;|import com.google.gson.Gson;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.JsonAdapter;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.$Gson$Types;|import com.google.gson.internal.ConstructorConstructor;|import com.google.gson.internal.Excluder;|import com.google.gson.internal.ObjectConstructor;|import com.google.gson.internal.Primitives;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;|import java.io.IOException;|import java.lang.reflect.Field;|import java.lang.reflect.Type;|import java.util.ArrayList;|import java.util.Collections;|import java.util.LinkedHashMap;|import java.util.List;|import java.util.Map;|import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;","ReflectiveTypeAdapterFactory implements TypeAdapterFactory { @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); public boolean excludeField(Field, boolean); static boolean excludeField(Field, boolean, Excluder); @Override public <T> TypeAdapter<T> create(Gson, TypeToken<T>); }","<FCTX>ReflectiveTypeAdapterFactory implements TypeAdapterFactory { @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); private Map<String, BoundField> getBoundFields(Gson, TypeToken<?>, Class<?>); private final ConstructorConstructor constructorConstructor; }</FCTX> <ECTX>public final class ConstructorConstructor { public ConstructorConstructor(Map<Type,InstanceCreator<?>>); public <T> ObjectConstructor<T> get(TypeToken<T>); } public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Class<? super T> getRawType(); }</ECTX>","<FCTX>ReflectiveTypeAdapterFactory implements TypeAdapterFactory { @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } public ReflectiveTypeAdapterFactory(ConstructorConstructor, FieldNamingStrategy, Excluder); <PRIVATE_FCTX>private Map<String, BoundField> getBoundFields(Gson, TypeToken<?>, Class<?>); private final ConstructorConstructor constructorConstructor;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class ConstructorConstructor { public ConstructorConstructor(Map<Type,InstanceCreator<?>>); public <T> ObjectConstructor<T> get(TypeToken<T>); } public class TypeToken<T> { @SuppressWarnings(""unchecked"") protected TypeToken(); @SuppressWarnings(""unchecked"") TypeToken(Type); public final Class<? super T> getRawType(); }</ECTX>"
Gson_11_0_TypeAdapters,Gson,11,0,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_11_1_TypeAdapters,Gson,11,1,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + type.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_11_2_TypeAdapters,Gson,11,2,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + boxed.getName() + ""+"" + unboxed.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_11_3_TypeAdapters,Gson,11,3,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX></ECTX>","<FCTX>TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return ""Factory[type="" + base.getName() + ""+"" + sub.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_11_4_TypeAdapters,Gson,11,4,com.google.gson.internal.bind.TypeAdapters,TypeAdapters,gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,TypeAdapters_ESTest,com/google/gson/internal/bind/TypeAdapters_ESTest.java,"package com.google.gson.internal.bind;","import java.io.IOException;|import java.math.BigDecimal;|import java.math.BigInteger;|import java.net.InetAddress;|import java.net.URI;|import java.net.URISyntaxException;|import java.net.URL;|import java.sql.Timestamp;|import java.util.ArrayList;|import java.util.BitSet;|import java.util.Calendar;|import java.util.Currency;|import java.util.Date;|import java.util.GregorianCalendar;|import java.util.HashMap;|import java.util.List;|import java.util.Locale;|import java.util.Map;|import java.util.StringTokenizer;|import java.util.UUID;|import java.util.concurrent.atomic.AtomicBoolean;|import java.util.concurrent.atomic.AtomicInteger;|import java.util.concurrent.atomic.AtomicIntegerArray;|import com.google.gson.Gson;|import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonIOException;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.JsonSyntaxException;|import com.google.gson.TypeAdapter;|import com.google.gson.TypeAdapterFactory;|import com.google.gson.annotations.SerializedName;|import com.google.gson.internal.LazilyParsedNumber;|import com.google.gson.reflect.TypeToken;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); public static <TT> TypeAdapterFactory newFactory(TypeToken<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, TypeAdapter<TT>); public static <TT> TypeAdapterFactory newFactory(Class<TT>, Class<TT>, TypeAdapter<?superTT>); public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT>, Class<?extendsTT>, TypeAdapter<?superTT>); public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1>, TypeAdapter<T1>); @SuppressWarnings(""rawtypes"") public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() { @Override public void write(JsonWriter out, Class value) throws IOException { if (value == null) { out.nullValue(); } else { throw new UnsupportedOperationException(""Attempted to serialize java.lang.Class: "" + value.getName() + "". Forgot to register a type adapter?""); } } @Override public Class read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else { throw new UnsupportedOperationException( ""Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?""); } } }; public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS); public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() { @Override public BitSet read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } BitSet bitset = new BitSet(); in.beginArray(); int i = 0; JsonToken tokenType = in.peek(); while (tokenType != JsonToken.END_ARRAY) { boolean set; switch (tokenType) { case NUMBER: set = in.nextInt() != 0; break; case BOOLEAN: set = in.nextBoolean(); break; case STRING: String stringValue = in.nextString(); try { set = Integer.parseInt(stringValue) != 0; } catch (NumberFormatException e) { throw new JsonSyntaxException( ""Error: Expecting: bitset number value (1, 0), Found: "" + stringValue); } break; default: throw new JsonSyntaxException(""Invalid bitset value type: "" + tokenType); } if (set) { bitset.set(i); } ++i; tokenType = in.peek(); } in.endArray(); return bitset; } @Override public void write(JsonWriter out, BitSet src) throws IOException { if (src == null) { out.nullValue(); return; } out.beginArray(); for (int i = 0; i < src.length(); i++) { int value = (src.get(i)) ? 1 : 0; out.value(value); } out.endArray(); } }; public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET); public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } else if (in.peek() == JsonToken.STRING) { return Boolean.parseBoolean(in.nextString()); } return in.nextBoolean(); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value); } }; public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() { @Override public Boolean read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return Boolean.valueOf(in.nextString()); } @Override public void write(JsonWriter out, Boolean value) throws IOException { out.value(value == null ? ""null"" : value.toString()); } }; public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN); public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { int intValue = in.nextInt(); return (byte) intValue; } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE); public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return (short) in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT); public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextInt(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER); public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() { @Override public AtomicInteger read(JsonReader in) throws IOException { try { return new AtomicInteger(in.nextInt()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, AtomicInteger value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER); public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() { @Override public AtomicBoolean read(JsonReader in) throws IOException { return new AtomicBoolean(in.nextBoolean()); } @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException { out.value(value.get()); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN); public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() { @Override public AtomicIntegerArray read(JsonReader in) throws IOException { List<Integer> list = new ArrayList<Integer>(); in.beginArray(); while (in.hasNext()) { try { int integer = in.nextInt(); list.add(integer); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } in.endArray(); int length = list.size(); AtomicIntegerArray array = new AtomicIntegerArray(length); for (int i = 0; i < length; ++i) { array.set(i, list.get(i)); } return array; } @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException { out.beginArray(); for (int i = 0, length = value.length(); i < length; i++) { out.value(value.get(i)); } out.endArray(); } }.nullSafe(); public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY); public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return in.nextLong(); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return (float) in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return in.nextDouble(); } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() { @Override public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: case STRING: return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken); } } @Override public void write(JsonWriter out, Number value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER); public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() { @Override public Character read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String str = in.nextString(); if (str.length() != 1) { throw new JsonSyntaxException(""Expecting character, got: "" + str); } return str.charAt(0); } @Override public void write(JsonWriter out, Character value) throws IOException { out.value(value == null ? null : String.valueOf(value)); } }; public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER); public static final TypeAdapter<String> STRING = new TypeAdapter<String>() { @Override public String read(JsonReader in) throws IOException { JsonToken peek = in.peek(); if (peek == JsonToken.NULL) { in.nextNull(); return null; } if (peek == JsonToken.BOOLEAN) { return Boolean.toString(in.nextBoolean()); } return in.nextString(); } @Override public void write(JsonWriter out, String value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() { @Override public BigDecimal read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigDecimal(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigDecimal value) throws IOException { out.value(value); } }; public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() { @Override public BigInteger read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { return new BigInteger(in.nextString()); } catch (NumberFormatException e) { throw new JsonSyntaxException(e); } } @Override public void write(JsonWriter out, BigInteger value) throws IOException { out.value(value); } }; public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING); public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() { @Override public StringBuilder read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuilder(in.nextString()); } @Override public void write(JsonWriter out, StringBuilder value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER); public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() { @Override public StringBuffer read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return new StringBuffer(in.nextString()); } @Override public void write(JsonWriter out, StringBuffer value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER); public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() { @Override public URL read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URL(nextString); } @Override public void write(JsonWriter out, URL value) throws IOException { out.value(value == null ? null : value.toExternalForm()); } }; public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL); public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() { @Override public URI read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } try { String nextString = in.nextString(); return ""null"".equals(nextString) ? null : new URI(nextString); } catch (URISyntaxException e) { throw new JsonIOException(e); } } @Override public void write(JsonWriter out, URI value) throws IOException { out.value(value == null ? null : value.toASCIIString()); } }; public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI); public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() { @Override public InetAddress read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return InetAddress.getByName(in.nextString()); } @Override public void write(JsonWriter out, InetAddress value) throws IOException { out.value(value == null ? null : value.getHostAddress()); } }; public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS); public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() { @Override public UUID read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } return java.util.UUID.fromString(in.nextString()); } @Override public void write(JsonWriter out, UUID value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID); public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() { @Override public Currency read(JsonReader in) throws IOException { return Currency.getInstance(in.nextString()); } @Override public void write(JsonWriter out, Currency value) throws IOException { out.value(value.getCurrencyCode()); } }.nullSafe(); public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY); public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { if (typeToken.getRawType() != Timestamp.class) { return null; } final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class); return (TypeAdapter<T>) new TypeAdapter<Timestamp>() { @Override public Timestamp read(JsonReader in) throws IOException { Date date = dateTypeAdapter.read(in); return date != null ? new Timestamp(date.getTime()) : null; } @Override public void write(JsonWriter out, Timestamp value) throws IOException { dateTypeAdapter.write(out, value); } }; } }; public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() { private static final String YEAR = ""year""; private static final String MONTH = ""month""; private static final String DAY_OF_MONTH = ""dayOfMonth""; private static final String HOUR_OF_DAY = ""hourOfDay""; private static final String MINUTE = ""minute""; private static final String SECOND = ""second""; @Override public Calendar read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } in.beginObject(); int year = 0; int month = 0; int dayOfMonth = 0; int hourOfDay = 0; int minute = 0; int second = 0; while (in.peek() != JsonToken.END_OBJECT) { String name = in.nextName(); int value = in.nextInt(); if (YEAR.equals(name)) { year = value; } else if (MONTH.equals(name)) { month = value; } else if (DAY_OF_MONTH.equals(name)) { dayOfMonth = value; } else if (HOUR_OF_DAY.equals(name)) { hourOfDay = value; } else if (MINUTE.equals(name)) { minute = value; } else if (SECOND.equals(name)) { second = value; } } in.endObject(); return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); } @Override public void write(JsonWriter out, Calendar value) throws IOException { if (value == null) { out.nullValue(); return; } out.beginObject(); out.name(YEAR); out.value(value.get(Calendar.YEAR)); out.name(MONTH); out.value(value.get(Calendar.MONTH)); out.name(DAY_OF_MONTH); out.value(value.get(Calendar.DAY_OF_MONTH)); out.name(HOUR_OF_DAY); out.value(value.get(Calendar.HOUR_OF_DAY)); out.name(MINUTE); out.value(value.get(Calendar.MINUTE)); out.name(SECOND); out.value(value.get(Calendar.SECOND)); out.endObject(); } }; public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR); public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() { @Override public Locale read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } String locale = in.nextString(); StringTokenizer tokenizer = new StringTokenizer(locale, ""_""); String language = null; String country = null; String variant = null; if (tokenizer.hasMoreElements()) { language = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { country = tokenizer.nextToken(); } if (tokenizer.hasMoreElements()) { variant = tokenizer.nextToken(); } if (country == null && variant == null) { return new Locale(language); } else if (variant == null) { return new Locale(language, country); } else { return new Locale(language, country, variant); } } @Override public void write(JsonWriter out, Locale value) throws IOException { out.value(value == null ? null : value.toString()); } }; public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE); public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() { @Override public JsonElement read(JsonReader in) throws IOException { switch (in.peek()) { case STRING: return new JsonPrimitive(in.nextString()); case NUMBER: String number = in.nextString(); return new JsonPrimitive(new LazilyParsedNumber(number)); case BOOLEAN: return new JsonPrimitive(in.nextBoolean()); case NULL: in.nextNull(); return JsonNull.INSTANCE; case BEGIN_ARRAY: JsonArray array = new JsonArray(); in.beginArray(); while (in.hasNext()) { array.add(read(in)); } in.endArray(); return array; case BEGIN_OBJECT: JsonObject object = new JsonObject(); in.beginObject(); while (in.hasNext()) { object.add(in.nextName(), read(in)); } in.endObject(); return object; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException(); } } @Override public void write(JsonWriter out, JsonElement value) throws IOException { if (value == null || value.isJsonNull()) { out.nullValue(); } else if (value.isJsonPrimitive()) { JsonPrimitive primitive = value.getAsJsonPrimitive(); if (primitive.isNumber()) { out.value(primitive.getAsNumber()); } else if (primitive.isBoolean()) { out.value(primitive.getAsBoolean()); } else { out.value(primitive.getAsString()); } } else if (value.isJsonArray()) { out.beginArray(); for (JsonElement e : value.getAsJsonArray()) { write(out, e); } out.endArray(); } else if (value.isJsonObject()) { out.beginObject(); for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) { out.name(e.getKey()); write(out, e.getValue()); } out.endObject(); } else { throw new IllegalArgumentException(""Couldn't write "" + value.getClass()); } } }; public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT); public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() { @SuppressWarnings({""rawtypes"", ""unchecked""}) @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) { return null; } if (!rawType.isEnum()) { rawType = rawType.getSuperclass(); } return (TypeAdapter<T>) new EnumTypeAdapter(rawType); } }; }","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } private TypeAdapters(); }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>","<FCTX>TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(""unchecked"") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(""Expected a "" + requestedType.getName() + "" but was "" + result.getClass().getName()); } return result; } }; } @Override public String toString() { return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]""; } }; } <PRIVATE_FCTX>private TypeAdapters();</PRIVATE_FCTX> }</FCTX> <ECTX>public abstract class TypeAdapter<T> { public abstract void write(JsonWriter, T); public abstract T read(JsonReader); }</ECTX>"
Gson_12_0_JsonTreeReader,Gson,12,0,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void beginArray() throws IOException { expect(JsonToken.BEGIN_ARRAY); JsonArray array = (JsonArray) peekStack(); push(array.iterator()); pathIndices[stackSize - 1] = 0; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void beginArray() throws IOException { expect(JsonToken.BEGIN_ARRAY); JsonArray array = (JsonArray) peekStack(); push(array.iterator()); pathIndices[stackSize - 1] = 0; } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object peekStack(); private void push(Object); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX>public final class JsonArray extends JsonElement implements Iterable<JsonElement> { public JsonArray(); public Iterator<JsonElement> iterator(); }</ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void beginArray() throws IOException { expect(JsonToken.BEGIN_ARRAY); JsonArray array = (JsonArray) peekStack(); push(array.iterator()); pathIndices[stackSize - 1] = 0; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object peekStack(); private void push(Object); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX>public final class JsonArray extends JsonElement implements Iterable<JsonElement> { public JsonArray(); public Iterator<JsonElement> iterator(); }</ECTX>"
Gson_12_1_JsonTreeReader,Gson,12,1,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void endArray() throws IOException { expect(JsonToken.END_ARRAY); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void endArray() throws IOException { expect(JsonToken.END_ARRAY); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void endArray() throws IOException { expect(JsonToken.END_ARRAY); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_2_JsonTreeReader,Gson,12,2,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public double nextDouble() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } double result = ((JsonPrimitive) peekStack()).getAsDouble(); if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) { throw new NumberFormatException(""JSON forbids NaN and infinities: "" + result); } popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public double nextDouble() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } double result = ((JsonPrimitive) peekStack()).getAsDouble(); if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) { throw new NumberFormatException(""JSON forbids NaN and infinities: "" + result); } popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public double nextDouble() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } double result = ((JsonPrimitive) peekStack()).getAsDouble(); if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) { throw new NumberFormatException(""JSON forbids NaN and infinities: "" + result); } popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_3_JsonTreeReader,Gson,12,3,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public long nextLong() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } long result = ((JsonPrimitive) peekStack()).getAsLong(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public long nextLong() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } long result = ((JsonPrimitive) peekStack()).getAsLong(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public long nextLong() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } long result = ((JsonPrimitive) peekStack()).getAsLong(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_4_JsonTreeReader,Gson,12,4,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public int nextInt() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } int result = ((JsonPrimitive) peekStack()).getAsInt(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public int nextInt() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } int result = ((JsonPrimitive) peekStack()).getAsInt(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public int nextInt() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString()); } int result = ((JsonPrimitive) peekStack()).getAsInt(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private String locationString(); private Object peekStack(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_5_JsonTreeReader,Gson,12,5,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void close() throws IOException { stack = new Object[] { SENTINEL_CLOSED }; stackSize = 1; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void close() throws IOException { stack = new Object[] { SENTINEL_CLOSED }; stackSize = 1; } public JsonTreeReader(JsonElement); private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void close() throws IOException { stack = new Object[] { SENTINEL_CLOSED }; stackSize = 1; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_6_JsonTreeReader,Gson,12,6,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void skipValue() throws IOException { if (peek() == JsonToken.NAME) { nextName(); pathNames[stackSize - 2] = ""null""; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = ""null""; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void skipValue() throws IOException { if (peek() == JsonToken.NAME) { nextName(); pathNames[stackSize - 2] = ""null""; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = ""null""; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); private Object popStack(); private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void skipValue() throws IOException { if (peek() == JsonToken.NAME) { nextName(); pathNames[stackSize - 2] = ""null""; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = ""null""; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private Object popStack(); private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_7_JsonTreeReader,Gson,12,7,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public String toString() { return getClass().getSimpleName(); } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public String toString() { return getClass().getSimpleName(); } public JsonTreeReader(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public String toString() { return getClass().getSimpleName(); } public JsonTreeReader(JsonElement); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_8_JsonTreeReader,Gson,12,8,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { public void promoteNameToValue() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); push(entry.getValue()); push(new JsonPrimitive((String) entry.getKey())); } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { public void promoteNameToValue() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); push(entry.getValue()); push(new JsonPrimitive((String) entry.getKey())); } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object peekStack(); private void push(Object); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { public void promoteNameToValue() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); push(entry.getValue()); push(new JsonPrimitive((String) entry.getKey())); } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object peekStack(); private void push(Object);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_9_JsonTreeReader,Gson,12,9,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0; i < stackSize; i++) { if (stack[i] instanceof JsonArray) { if (stack[++i] instanceof Iterator) { result.append('[').append(pathIndices[i]).append(']'); } } else if (stack[i] instanceof JsonObject) { if (stack[++i] instanceof Iterator) { result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } } } } return result.toString(); } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0; i < stackSize; i++) { if (stack[i] instanceof JsonArray) { if (stack[++i] instanceof Iterator) { result.append('[').append(pathIndices[i]).append(']'); } } else if (stack[i] instanceof JsonObject) { if (stack[++i] instanceof Iterator) { result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } } } } return result.toString(); } public JsonTreeReader(JsonElement); private Object[] stack = new Object[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0; i < stackSize; i++) { if (stack[i] instanceof JsonArray) { if (stack[++i] instanceof Iterator) { result.append('[').append(pathIndices[i]).append(']'); } } else if (stack[i] instanceof JsonObject) { if (stack[++i] instanceof Iterator) { result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } } } } return result.toString(); } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private Object[] stack = new Object[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_10_JsonTreeReader,Gson,12,10,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void beginObject() throws IOException { expect(JsonToken.BEGIN_OBJECT); JsonObject object = (JsonObject) peekStack(); push(object.entrySet().iterator()); } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void beginObject() throws IOException { expect(JsonToken.BEGIN_OBJECT); JsonObject object = (JsonObject) peekStack(); push(object.entrySet().iterator()); } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object peekStack(); private void push(Object); }</FCTX> <ECTX>public final class JsonObject extends JsonElement { public Set<Map.Entry<String, JsonElement>> entrySet(); }</ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void beginObject() throws IOException { expect(JsonToken.BEGIN_OBJECT); JsonObject object = (JsonObject) peekStack(); push(object.entrySet().iterator()); } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object peekStack(); private void push(Object);</PRIVATE_FCTX> }</FCTX> <ECTX>public final class JsonObject extends JsonElement { public Set<Map.Entry<String, JsonElement>> entrySet(); }</ECTX>"
Gson_12_11_JsonTreeReader,Gson,12,11,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void endObject() throws IOException { expect(JsonToken.END_OBJECT); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void endObject() throws IOException { expect(JsonToken.END_OBJECT); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void endObject() throws IOException { expect(JsonToken.END_OBJECT); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_12_JsonTreeReader,Gson,12,12,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public boolean hasNext() throws IOException { JsonToken token = peek(); return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public boolean hasNext() throws IOException { JsonToken token = peek(); return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; } public JsonTreeReader(JsonElement); }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public boolean hasNext() throws IOException { JsonToken token = peek(); return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_13_JsonTreeReader,Gson,12,13,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public JsonToken peek() throws IOException { if (stackSize == 0) { return JsonToken.END_DOCUMENT; } Object o = peekStack(); if (o instanceof Iterator) { boolean isObject = stack[stackSize - 2] instanceof JsonObject; Iterator<?> iterator = (Iterator<?>) o; if (iterator.hasNext()) { if (isObject) { return JsonToken.NAME; } else { push(iterator.next()); return peek(); } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; } } else if (o instanceof JsonObject) { return JsonToken.BEGIN_OBJECT; } else if (o instanceof JsonArray) { return JsonToken.BEGIN_ARRAY; } else if (o instanceof JsonPrimitive) { JsonPrimitive primitive = (JsonPrimitive) o; if (primitive.isString()) { return JsonToken.STRING; } else if (primitive.isBoolean()) { return JsonToken.BOOLEAN; } else if (primitive.isNumber()) { return JsonToken.NUMBER; } else { throw new AssertionError(); } } else if (o instanceof JsonNull) { return JsonToken.NULL; } else if (o == SENTINEL_CLOSED) { throw new IllegalStateException(""JsonReader is closed""); } else { throw new AssertionError(); } } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public JsonToken peek() throws IOException { if (stackSize == 0) { return JsonToken.END_DOCUMENT; } Object o = peekStack(); if (o instanceof Iterator) { boolean isObject = stack[stackSize - 2] instanceof JsonObject; Iterator<?> iterator = (Iterator<?>) o; if (iterator.hasNext()) { if (isObject) { return JsonToken.NAME; } else { push(iterator.next()); return peek(); } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; } } else if (o instanceof JsonObject) { return JsonToken.BEGIN_OBJECT; } else if (o instanceof JsonArray) { return JsonToken.BEGIN_ARRAY; } else if (o instanceof JsonPrimitive) { JsonPrimitive primitive = (JsonPrimitive) o; if (primitive.isString()) { return JsonToken.STRING; } else if (primitive.isBoolean()) { return JsonToken.BOOLEAN; } else if (primitive.isNumber()) { return JsonToken.NUMBER; } else { throw new AssertionError(); } } else if (o instanceof JsonNull) { return JsonToken.NULL; } else if (o == SENTINEL_CLOSED) { throw new IllegalStateException(""JsonReader is closed""); } else { throw new AssertionError(); } } public JsonTreeReader(JsonElement); private Object peekStack(); private void push(Object); private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0; }</FCTX> <ECTX>public final class JsonPrimitive extends JsonElement { public JsonPrimitive(Boolean); public JsonPrimitive(Number); public JsonPrimitive(String); public JsonPrimitive(Character); JsonPrimitive(Object); public boolean isString(); public boolean isBoolean(); public boolean isNumber(); }</ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public JsonToken peek() throws IOException { if (stackSize == 0) { return JsonToken.END_DOCUMENT; } Object o = peekStack(); if (o instanceof Iterator) { boolean isObject = stack[stackSize - 2] instanceof JsonObject; Iterator<?> iterator = (Iterator<?>) o; if (iterator.hasNext()) { if (isObject) { return JsonToken.NAME; } else { push(iterator.next()); return peek(); } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; } } else if (o instanceof JsonObject) { return JsonToken.BEGIN_OBJECT; } else if (o instanceof JsonArray) { return JsonToken.BEGIN_ARRAY; } else if (o instanceof JsonPrimitive) { JsonPrimitive primitive = (JsonPrimitive) o; if (primitive.isString()) { return JsonToken.STRING; } else if (primitive.isBoolean()) { return JsonToken.BOOLEAN; } else if (primitive.isNumber()) { return JsonToken.NUMBER; } else { throw new AssertionError(); } } else if (o instanceof JsonNull) { return JsonToken.NULL; } else if (o == SENTINEL_CLOSED) { throw new IllegalStateException(""JsonReader is closed""); } else { throw new AssertionError(); } } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private Object peekStack(); private void push(Object); private static final Object SENTINEL_CLOSED = new Object(); private Object[] stack = new Object[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX>public final class JsonPrimitive extends JsonElement { public JsonPrimitive(Boolean); public JsonPrimitive(Number); public JsonPrimitive(String); public JsonPrimitive(Character); JsonPrimitive(Object); public boolean isString(); public boolean isBoolean(); public boolean isNumber(); }</ECTX>"
Gson_12_14_JsonTreeReader,Gson,12,14,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public String nextName() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); String result = (String) entry.getKey(); pathNames[stackSize - 1] = result; push(entry.getValue()); return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public String nextName() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); String result = (String) entry.getKey(); pathNames[stackSize - 1] = result; push(entry.getValue()); return result; } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object peekStack(); private void push(Object); private int stackSize = 0; private String[] pathNames = new String[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public String nextName() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); String result = (String) entry.getKey(); pathNames[stackSize - 1] = result; push(entry.getValue()); return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object peekStack(); private void push(Object); private int stackSize = 0; private String[] pathNames = new String[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_15_JsonTreeReader,Gson,12,15,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public String nextString() throws IOException { JsonToken token = peek(); if (token != JsonToken.STRING && token != JsonToken.NUMBER) { throw new IllegalStateException( ""Expected "" + JsonToken.STRING + "" but was "" + token + locationString()); } String result = ((JsonPrimitive) popStack()).getAsString(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public String nextString() throws IOException { JsonToken token = peek(); if (token != JsonToken.STRING && token != JsonToken.NUMBER) { throw new IllegalStateException( ""Expected "" + JsonToken.STRING + "" but was "" + token + locationString()); } String result = ((JsonPrimitive) popStack()).getAsString(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); private String locationString(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public String nextString() throws IOException { JsonToken token = peek(); if (token != JsonToken.STRING && token != JsonToken.NUMBER) { throw new IllegalStateException( ""Expected "" + JsonToken.STRING + "" but was "" + token + locationString()); } String result = ((JsonPrimitive) popStack()).getAsString(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private String locationString(); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_16_JsonTreeReader,Gson,12,16,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public boolean nextBoolean() throws IOException { expect(JsonToken.BOOLEAN); boolean result = ((JsonPrimitive) popStack()).getAsBoolean(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public boolean nextBoolean() throws IOException { expect(JsonToken.BOOLEAN); boolean result = ((JsonPrimitive) popStack()).getAsBoolean(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public boolean nextBoolean() throws IOException { expect(JsonToken.BOOLEAN); boolean result = ((JsonPrimitive) popStack()).getAsBoolean(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_12_17_JsonTreeReader,Gson,12,17,com.google.gson.internal.bind.JsonTreeReader,JsonTreeReader,gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java,JsonTreeReader_ESTest,com/google/gson/internal/bind/JsonTreeReader_ESTest.java,"package com.google.gson.internal.bind;","import com.google.gson.JsonArray;|import com.google.gson.JsonElement;|import com.google.gson.JsonNull;|import com.google.gson.JsonObject;|import com.google.gson.JsonPrimitive;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import java.io.IOException;|import java.io.Reader;|import java.util.Iterator;|import java.util.Map;","JsonTreeReader extends JsonReader { @Override public void nextNull() throws IOException { expect(JsonToken.NULL); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); @Override public void beginArray(); @Override public void endArray(); @Override public void beginObject(); @Override public void endObject(); @Override public boolean hasNext(); @Override public JsonToken peek(); @Override public String nextName(); @Override public String nextString(); @Override public boolean nextBoolean(); @Override public void nextNull(); @Override public double nextDouble(); @Override public long nextLong(); @Override public int nextInt(); @Override public void close(); @Override public void skipValue(); @Override public String toString(); public void promoteNameToValue(); @Override public String getPath(); }","<FCTX>JsonTreeReader extends JsonReader { @Override public void nextNull() throws IOException { expect(JsonToken.NULL); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonTreeReader extends JsonReader { @Override public void nextNull() throws IOException { expect(JsonToken.NULL); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } public JsonTreeReader(JsonElement); <PRIVATE_FCTX>private void expect(JsonToken); private Object popStack(); private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_0_JsonReader,Gson,13,0,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_1_JsonReader,Gson,13,1,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public final boolean isLenient() { return lenient; } public JsonReader(Reader); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_2_JsonReader,Gson,13,2,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString()); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString()); } public JsonReader(Reader); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString()); } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_3_JsonReader,Gson,13,3,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + locationString()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + locationString()); } } public JsonReader(Reader); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException(""Expected null but was "" + peek() + locationString()); } } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_NULL = 7; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_4_JsonReader,Gson,13,4,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException( ""JSON forbids NaN and infinities: "" + result + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException( ""JSON forbids NaN and infinities: "" + result + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(""Expected a double but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException( ""JSON forbids NaN and infinities: "" + result + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String nextQuotedValue(char); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private boolean lenient = false; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_5_JsonReader,Gson,13,5,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected a long but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_6_JsonReader,Gson,13,6,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); private String locationString(); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(""Expected an int but was "" + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString(); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_7_JsonReader,Gson,13,7,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private final Reader in; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_8_JsonReader,Gson,13,8,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('""'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = ""null""; } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private void skipUnquotedValue(); private void skipQuotedValue(char); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_NUMBER = 16; private int pos = 0; private int peekedNumberLength; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_9_JsonReader,Gson,13,9,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + locationString(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + locationString(); } public JsonReader(Reader); private String locationString(); }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + locationString(); } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_10_JsonReader,Gson,13,10,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } public JsonReader(Reader); <PRIVATE_FCTX>private int[] stack = new int[32]; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_11_JsonReader,Gson,13,11,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); private void push(int); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_ARRAY = 3; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_12_JsonReader,Gson,13,12,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString()); } } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_ARRAY = 4; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_13_JsonReader,Gson,13,13,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); private void push(int); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); <PRIVATE_FCTX>private void push(int); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_14_JsonReader,Gson,13,14,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString()); } } public JsonReader(Reader); <PRIVATE_FCTX>private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private int stackSize = 0; private String[] pathNames = new String[32]; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_15_JsonReader,Gson,13,15,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_END_ARRAY = 4;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_16_JsonReader,Gson,13,16,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } public JsonReader(Reader); <PRIVATE_FCTX>private static final int PEEKED_NONE = 0; private static final int PEEKED_BEGIN_OBJECT = 1; private static final int PEEKED_END_OBJECT = 2; private static final int PEEKED_BEGIN_ARRAY = 3; private static final int PEEKED_END_ARRAY = 4; private static final int PEEKED_TRUE = 5; private static final int PEEKED_FALSE = 6; private static final int PEEKED_NULL = 7; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private static final int PEEKED_EOF = 17;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_17_JsonReader,Gson,13,17,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('""'); } else { throw new IllegalStateException(""Expected a name but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED_NAME = 12; private static final int PEEKED_DOUBLE_QUOTED_NAME = 13; private static final int PEEKED_UNQUOTED_NAME = 14; private int stackSize = 0; private String[] pathNames = new String[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_13_18_JsonReader,Gson,13,18,com.google.gson.stream.JsonReader,JsonReader,gson/src/main/java/com/google/gson/stream/JsonReader.java,JsonReader_ESTest,com/google/gson/stream/JsonReader_ESTest.java,"package com.google.gson.stream;","import com.google.gson.internal.JsonReaderInternalAccess;|import com.google.gson.internal.bind.JsonTreeReader;|import java.io.Closeable;|import java.io.EOFException;|import java.io.IOException;|import java.io.Reader;","JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); public final void setLenient(boolean); public final boolean isLenient(); public void beginArray(); public void endArray(); public void beginObject(); public void endObject(); public boolean hasNext(); public JsonToken peek(); int doPeek(); public String nextName(); public String nextString(); public boolean nextBoolean(); public void nextNull(); public double nextDouble(); public long nextLong(); public int nextInt(); public void close(); public void skipValue(); @Override public String toString(); public String getPath(); int peeked = PEEKED_NONE; }","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); @SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32]; }</FCTX> <ECTX></ECTX>","<FCTX>JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('""'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException(""Expected a string but was "" + peek() + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } public JsonReader(Reader); <PRIVATE_FCTX>@SuppressWarnings(""fallthrough"") private String nextUnquotedValue(); private String nextQuotedValue(char); private String locationString(); private static final int PEEKED_NONE = 0; private static final int PEEKED_SINGLE_QUOTED = 8; private static final int PEEKED_DOUBLE_QUOTED = 9; private static final int PEEKED_UNQUOTED = 10; private static final int PEEKED_BUFFERED = 11; private static final int PEEKED_LONG = 15; private static final int PEEKED_NUMBER = 16; private final char[] buffer = new char[1024]; private int pos = 0; private long peekedLong; private int peekedNumberLength; private String peekedString; private int stackSize = 0; private int[] pathIndices = new int[32];</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_0_$Gson$Types,Gson,14,0,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_1_$Gson$Types,Gson,14,1,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_2_$Gson$Types,Gson,14,2,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_3_$Gson$Types,Gson,14,3,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve; } } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) { Class<?> original = (Class<?>) toResolve; Type componentType = original.getComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof GenericArrayType) { GenericArrayType original = (GenericArrayType) toResolve; Type componentType = original.getGenericComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof ParameterizedType) { ParameterizedType original = (ParameterizedType) toResolve; Type ownerType = original.getOwnerType(); Type newOwnerType = resolve(context, contextRawType, ownerType); boolean changed = newOwnerType != ownerType; Type[] args = original.getActualTypeArguments(); for (int t = 0, length = args.length; t < length; t++) { Type resolvedTypeArgument = resolve(context, contextRawType, args[t]); if (resolvedTypeArgument != args[t]) { if (!changed) { args = args.clone(); changed = true; } args[t] = resolvedTypeArgument; } } return changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original; } else if (toResolve instanceof WildcardType) { WildcardType original = (WildcardType) toResolve; Type[] originalLowerBound = original.getLowerBounds(); Type[] originalUpperBound = original.getUpperBounds(); if (originalLowerBound.length == 1) { Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]); if (lowerBound != originalLowerBound[0]) { return supertypeOf(lowerBound); } } else if (originalUpperBound.length == 1) { Type upperBound = resolve(context, contextRawType, originalUpperBound[0]); if (upperBound != originalUpperBound[0]) { return subtypeOf(upperBound); } } return original; } else { return toResolve; } } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve; } } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) { Class<?> original = (Class<?>) toResolve; Type componentType = original.getComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof GenericArrayType) { GenericArrayType original = (GenericArrayType) toResolve; Type componentType = original.getGenericComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof ParameterizedType) { ParameterizedType original = (ParameterizedType) toResolve; Type ownerType = original.getOwnerType(); Type newOwnerType = resolve(context, contextRawType, ownerType); boolean changed = newOwnerType != ownerType; Type[] args = original.getActualTypeArguments(); for (int t = 0, length = args.length; t < length; t++) { Type resolvedTypeArgument = resolve(context, contextRawType, args[t]); if (resolvedTypeArgument != args[t]) { if (!changed) { args = args.clone(); changed = true; } args[t] = resolvedTypeArgument; } } return changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original; } else if (toResolve instanceof WildcardType) { WildcardType original = (WildcardType) toResolve; Type[] originalLowerBound = original.getLowerBounds(); Type[] originalUpperBound = original.getUpperBounds(); if (originalLowerBound.length == 1) { Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]); if (lowerBound != originalLowerBound[0]) { return supertypeOf(lowerBound); } } else if (originalUpperBound.length == 1) { Type upperBound = resolve(context, contextRawType, originalUpperBound[0]); if (upperBound != originalUpperBound[0]) { return subtypeOf(upperBound); } } return original; } else { return toResolve; } } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve; } } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) { Class<?> original = (Class<?>) toResolve; Type componentType = original.getComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof GenericArrayType) { GenericArrayType original = (GenericArrayType) toResolve; Type componentType = original.getGenericComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof ParameterizedType) { ParameterizedType original = (ParameterizedType) toResolve; Type ownerType = original.getOwnerType(); Type newOwnerType = resolve(context, contextRawType, ownerType); boolean changed = newOwnerType != ownerType; Type[] args = original.getActualTypeArguments(); for (int t = 0, length = args.length; t < length; t++) { Type resolvedTypeArgument = resolve(context, contextRawType, args[t]); if (resolvedTypeArgument != args[t]) { if (!changed) { args = args.clone(); changed = true; } args[t] = resolvedTypeArgument; } } return changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original; } else if (toResolve instanceof WildcardType) { WildcardType original = (WildcardType) toResolve; Type[] originalLowerBound = original.getLowerBounds(); Type[] originalUpperBound = original.getUpperBounds(); if (originalLowerBound.length == 1) { Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]); if (lowerBound != originalLowerBound[0]) { return supertypeOf(lowerBound); } } else if (originalUpperBound.length == 1) { Type upperBound = resolve(context, contextRawType, originalUpperBound[0]); if (upperBound != originalUpperBound[0]) { return subtypeOf(upperBound); } } return original; } else { return toResolve; } } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_4_$Gson$Types,Gson,14,4,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_5_$Gson$Types,Gson,14,5,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_6_$Gson$Types,Gson,14,6,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_7_$Gson$Types,Gson,14,7,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>"
Gson_14_8_$Gson$Types,Gson,14,8,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_9_$Gson$Types,Gson,14,9,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_10_$Gson$Types,Gson,14,10,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_14_11_$Gson$Types,Gson,14,11,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.Arrays;|import java.util.Collection;|import java.util.Map;|import java.util.NoSuchElementException;|import java.util.Properties;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_0_JsonWriter,Gson,15,0,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); private String indent; private String separator = "":""; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = "":""; } else { this.indent = indent; this.separator = "": ""; } } public JsonWriter(Writer); <PRIVATE_FCTX>private String indent; private String separator = "":"";</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_1_JsonWriter,Gson,15,1,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_2_JsonWriter,Gson,15,2,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; static final int NONEMPTY_OBJECT = 5; }</ECTX>"
Gson_15_3_JsonWriter,Gson,15,3,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); private int stackSize = 0; private String deferredName; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException(""name == null""); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } deferredName = name; return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private int stackSize = 0; private String deferredName;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_4_JsonWriter,Gson,15,4,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private void string(String);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_5_JsonWriter,Gson,15,5,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_6_JsonWriter,Gson,15,6,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write(""null""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private String deferredName; private boolean serializeNulls = true;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_7_JsonWriter,Gson,15,7,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_8_JsonWriter,Gson,15,8,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? ""true"" : ""false""); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_9_JsonWriter,Gson,15,9,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(Double.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_10_JsonWriter,Gson,15,10,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_11_JsonWriter,Gson,15,11,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) { throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value); } beforeValue(); out.append(string); return this; } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); @SuppressWarnings(""fallthrough"") private void beforeValue(); private final Writer out; private boolean lenient;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_12_JsonWriter,Gson,15,12,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_13_JsonWriter,Gson,15,13,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); private final Writer out; private int stackSize = 0; }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException(""JsonWriter is closed.""); } out.flush(); } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_14_JsonWriter,Gson,15,14,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); private final Writer out; private int[] stack = new int[32]; private int stackSize = 0; }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException(""Incomplete document""); } stackSize = 0; } public JsonWriter(Writer); <PRIVATE_FCTX>private final Writer out; private int[] stack = new int[32]; private int stackSize = 0;</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int NONEMPTY_DOCUMENT = 7; }</ECTX>"
Gson_15_15_JsonWriter,Gson,15,15,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_16_JsonWriter,Gson,15,16,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_17_JsonWriter,Gson,15,17,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_18_JsonWriter,Gson,15,18,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); }</FCTX> <ECTX></ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } public JsonWriter(Writer); <PRIVATE_FCTX></PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_15_19_JsonWriter,Gson,15,19,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, ""[""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; }</ECTX>"
Gson_15_20_JsonWriter,Gson,15,20,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); private JsonWriter close(int, int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]""); } public JsonWriter(Writer); <PRIVATE_FCTX>private JsonWriter close(int, int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_ARRAY = 1; static final int NONEMPTY_ARRAY = 2; }</ECTX>"
Gson_15_21_JsonWriter,Gson,15,21,com.google.gson.stream.JsonWriter,JsonWriter,gson/src/main/java/com/google/gson/stream/JsonWriter.java,JsonWriter_ESTest,com/google/gson/stream/JsonWriter_ESTest.java,"package com.google.gson.stream;","import java.io.Closeable;|import java.io.Flushable;|import java.io.IOException;|import java.io.Writer;|import static com.google.gson.stream.JsonScope.DANGLING_NAME;|import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;|import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;|import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;|import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;","JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); public final void setIndent(String); public final void setLenient(boolean); public boolean isLenient(); public final void setHtmlSafe(boolean); public final boolean isHtmlSafe(); public final void setSerializeNulls(boolean); public final boolean getSerializeNulls(); public JsonWriter beginArray(); public JsonWriter endArray(); public JsonWriter beginObject(); public JsonWriter endObject(); public JsonWriter name(String); public JsonWriter value(String); public JsonWriter jsonValue(String); public JsonWriter nullValue(); public JsonWriter value(boolean); public JsonWriter value(Boolean); public JsonWriter value(double); public JsonWriter value(long); public JsonWriter value(Number); public void flush(); public void close(); }","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); private void writeDeferredName(); private JsonWriter open(int, String); }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>","<FCTX>JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, ""{""); } public JsonWriter(Writer); <PRIVATE_FCTX>private void writeDeferredName(); private JsonWriter open(int, String);</PRIVATE_FCTX> }</FCTX> <ECTX>final class JsonScope { static final int EMPTY_OBJECT = 3; }</ECTX>"
Gson_16_0_$Gson$Types,Gson,16,0,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_1_$Gson$Types,Gson,16,1,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_2_$Gson$Types,Gson,16,2,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_3_$Gson$Types,Gson,16,3,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } private $Gson$Types(); private static Type resolve(Type, Class<?>, Type, Collection<TypeVariable>); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } <PRIVATE_FCTX>private $Gson$Types(); private static Type resolve(Type, Class<?>, Type, Collection<TypeVariable>);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_4_$Gson$Types,Gson,16,4,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_5_$Gson$Types,Gson,16,5,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_6_$Gson$Types,Gson,16,6,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_7_$Gson$Types,Gson,16,7,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>"
Gson_16_8_$Gson$Types,Gson,16,8,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_9_$Gson$Types,Gson,16,9,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_10_$Gson$Types,Gson,16,10,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_16_11_$Gson$Types,Gson,16,11,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_17_0_DefaultDateTypeAdapter,Gson,17,0,com.google.gson.DefaultDateTypeAdapter,DefaultDateTypeAdapter,gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java,DefaultDateTypeAdapter_ESTest,com/google/gson/DefaultDateTypeAdapter_ESTest.java,"package com.google.gson;","import java.io.IOException;|import java.sql.Timestamp;|import java.text.DateFormat;|import java.text.ParseException;|import java.text.ParsePosition;|import java.text.SimpleDateFormat;|import java.util.Date;|import java.util.Locale;|import com.google.gson.internal.bind.util.ISO8601Utils;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public void write(JsonWriter out, Date value) throws IOException { if (value == null) { out.nullValue(); return; } synchronized (localFormat) { String dateFormatAsString = enUsFormat.format(value); out.value(dateFormatAsString); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); @Override public void write(JsonWriter, Date); @Override public Date read(JsonReader); @Override public String toString(); }","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public void write(JsonWriter out, Date value) throws IOException { if (value == null) { out.nullValue(); return; } synchronized (localFormat) { String dateFormatAsString = enUsFormat.format(value); out.value(dateFormatAsString); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); private final DateFormat enUsFormat; private final DateFormat localFormat; }</FCTX> <ECTX>public class JsonWriter implements Closeable, Flushable { public JsonWriter(Writer); public JsonWriter nullValue(); public JsonWriter value(String); }</ECTX>","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public void write(JsonWriter out, Date value) throws IOException { if (value == null) { out.nullValue(); return; } synchronized (localFormat) { String dateFormatAsString = enUsFormat.format(value); out.value(dateFormatAsString); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); <PRIVATE_FCTX>private final DateFormat enUsFormat; private final DateFormat localFormat;</PRIVATE_FCTX> }</FCTX> <ECTX>public class JsonWriter implements Closeable, Flushable { public JsonWriter(Writer); public JsonWriter nullValue(); public JsonWriter value(String); }</ECTX>"
Gson_17_1_DefaultDateTypeAdapter,Gson,17,1,com.google.gson.DefaultDateTypeAdapter,DefaultDateTypeAdapter,gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java,DefaultDateTypeAdapter_ESTest,com/google/gson/DefaultDateTypeAdapter_ESTest.java,"package com.google.gson;","import java.io.IOException;|import java.sql.Timestamp;|import java.text.DateFormat;|import java.text.ParseException;|import java.text.ParsePosition;|import java.text.SimpleDateFormat;|import java.util.Date;|import java.util.Locale;|import com.google.gson.internal.bind.util.ISO8601Utils;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); @Override public void write(JsonWriter, Date); @Override public Date read(JsonReader); @Override public String toString(); }","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); private Date deserializeToDate(String); private final Class<? extends Date> dateType; }</FCTX> <ECTX>public class JsonReader implements Closeable { public JsonReader(Reader); public JsonToken peek(); public void nextNull(); public String nextString(); }</ECTX>","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); <PRIVATE_FCTX>private Date deserializeToDate(String); private final Class<? extends Date> dateType;</PRIVATE_FCTX> }</FCTX> <ECTX>public class JsonReader implements Closeable { public JsonReader(Reader); public JsonToken peek(); public void nextNull(); public String nextString(); }</ECTX>"
Gson_17_2_DefaultDateTypeAdapter,Gson,17,2,com.google.gson.DefaultDateTypeAdapter,DefaultDateTypeAdapter,gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java,DefaultDateTypeAdapter_ESTest,com/google/gson/DefaultDateTypeAdapter_ESTest.java,"package com.google.gson;","import java.io.IOException;|import java.sql.Timestamp;|import java.text.DateFormat;|import java.text.ParseException;|import java.text.ParsePosition;|import java.text.SimpleDateFormat;|import java.util.Date;|import java.util.Locale;|import com.google.gson.internal.bind.util.ISO8601Utils;|import com.google.gson.stream.JsonReader;|import com.google.gson.stream.JsonToken;|import com.google.gson.stream.JsonWriter;","DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(SIMPLE_NAME); sb.append('(').append(localFormat.getClass().getSimpleName()).append(')'); return sb.toString(); } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); @Override public void write(JsonWriter, Date); @Override public Date read(JsonReader); @Override public String toString(); }","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(SIMPLE_NAME); sb.append('(').append(localFormat.getClass().getSimpleName()).append(')'); return sb.toString(); } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); private static final String SIMPLE_NAME = ""DefaultDateTypeAdapter""; private final DateFormat localFormat; }</FCTX> <ECTX></ECTX>","<FCTX>DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(SIMPLE_NAME); sb.append('(').append(localFormat.getClass().getSimpleName()).append(')'); return sb.toString(); } DefaultDateTypeAdapter(Class<?extendsDate>); DefaultDateTypeAdapter(Class<?extendsDate>, String); DefaultDateTypeAdapter(Class<?extendsDate>, int); public DefaultDateTypeAdapter(int, int); public DefaultDateTypeAdapter(Class<?extendsDate>, int, int); DefaultDateTypeAdapter(Class<?extendsDate>, DateFormat, DateFormat); <PRIVATE_FCTX>private static final String SIMPLE_NAME = ""DefaultDateTypeAdapter""; private final DateFormat localFormat;</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_0_$Gson$Types,Gson,18,0,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type...typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_1_$Gson$Types,Gson,18,1,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_2_$Gson$Types,Gson,18,2,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_3_$Gson$Types,Gson,18,3,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } private $Gson$Types(); private static Type resolve(Type, Class<?>, Type, Collection<TypeVariable>); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } <PRIVATE_FCTX>private $Gson$Types(); private static Type resolve(Type, Class<?>, Type, Collection<TypeVariable>);</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_4_$Gson$Types,Gson,18,4,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_5_$Gson$Types,Gson,18,5,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_6_$Gson$Types,Gson,18,6,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_7_$Gson$Types,Gson,18,7,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } private $Gson$Types(); }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>","<FCTX>$Gson$Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? ""null"" : type.getClass().getName(); throw new IllegalArgumentException(""Expected a Class, ParameterizedType, or "" + ""GenericArrayType, but <"" + type + ""> is of type "" + className); } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX>public final class $Gson$Preconditions { public static void checkArgument(boolean); }</ECTX>"
Gson_18_8_$Gson$Types,Gson,18,8,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_9_$Gson$Types,Gson,18,9,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_10_$Gson$Types,Gson,18,10,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
Gson_18_11_$Gson$Types,Gson,18,11,com.google.gson.internal.$Gson$Types,$Gson$Types,gson/src/main/java/com/google/gson/internal/$Gson$Types.java,$Gson$Types_ESTest,com/google/gson/internal/$Gson$Types_ESTest.java,"package com.google.gson.internal;","import java.io.Serializable;|import java.lang.reflect.Array;|import java.lang.reflect.GenericArrayType;|import java.lang.reflect.GenericDeclaration;|import java.lang.reflect.Modifier;|import java.lang.reflect.ParameterizedType;|import java.lang.reflect.Type;|import java.lang.reflect.TypeVariable;|import java.lang.reflect.WildcardType;|import java.util.*;|import static com.google.gson.internal.$Gson$Preconditions.checkArgument;|import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;","$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); public static ParameterizedType newParameterizedTypeWithOwner(Type, Type, Type); public static GenericArrayType arrayOf(Type); public static WildcardType subtypeOf(Type); public static WildcardType supertypeOf(Type); public static Type canonicalize(Type); public static Class<?> getRawType(Type); static boolean equal(Object, Object); public static boolean equals(Type, Type); static int hashCodeOrZero(Object); public static String typeToString(Type); static Type getGenericSupertype(Type, Class<?>, Class<?>); static Type getSupertype(Type, Class<?>, Class<?>); public static Type getArrayComponentType(Type); public static Type getCollectionElementType(Type, Class<?>); public static Type[] getMapKeyAndValueTypes(Type, Class<?>); public static Type resolve(Type, Class<?>, Type); static Type resolveTypeVariable(Type, Class<?>, TypeVariable<?>); static void checkNotPrimitive(Type); static final Type[] EMPTY_TYPE_ARRAY = new Type[] {}; }","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } private $Gson$Types(); }</FCTX> <ECTX></ECTX>","<FCTX>$Gson$Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } <PRIVATE_FCTX>private $Gson$Types();</PRIVATE_FCTX> }</FCTX> <ECTX></ECTX>"
